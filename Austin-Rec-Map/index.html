<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Psychojelly Recommendation Map</title>
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #1a1a2e;
      color: #eee;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      background: #16213e;
      border-bottom: 2px solid #0f3460;
      z-index: 1000;
      flex-wrap: wrap;
      gap: 8px;
    }

    header h1 { font-size: 1.3rem; font-weight: 700; letter-spacing: 1px; }
    header h1 span { color: #e94560; }

    .btn {
      padding: 6px 14px; border: none; border-radius: 6px; cursor: pointer;
      font-size: 0.85rem; font-weight: 600; transition: opacity 0.2s;
    }
    .btn:hover { opacity: 0.85; }
    .btn-primary { background: #0f3460; color: #eee; }
    .btn-danger  { background: #e94560; color: #fff; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    #map { flex: 1; z-index: 1; }

    /* Filter section (inside sidebar) */
    .legend-section {
      padding: 10px 14px; border-bottom: 1px solid #0f3460; flex-shrink: 0;
    }
    .legend-section-header {
      display: flex; align-items: center; justify-content: space-between;
      cursor: pointer; user-select: none;
    }
    .legend-section-header h3 {
      font-size: 0.75rem; margin: 0; color: #aaa;
      text-transform: uppercase; letter-spacing: 1px;
    }
    .legend-section-toggle {
      background: none; border: none; color: #aaa; cursor: pointer;
      font-size: 0.75rem; padding: 0 2px; transition: transform 0.2s;
    }
    .legend-section-toggle.collapsed { transform: rotate(180deg); }
    .legend-grid {
      display: flex; flex-wrap: wrap; gap: 4px; margin-top: 8px;
    }
    .legend-grid.collapsed { display: none; }
    .legend-item {
      display: flex; align-items: center; gap: 5px;
      padding: 3px 8px; border-radius: 6px; font-size: 0.72rem;
      cursor: pointer; user-select: none; transition: opacity 0.2s;
      background: rgba(255,255,255,0.05);
    }
    .legend-item:hover { background: rgba(255,255,255,0.1); }
    .legend-item.disabled { opacity: 0.35; }
    .legend-dot {
      width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
      border: 1.5px solid rgba(255,255,255,0.3);
    }

    /* Modal */
    .modal-overlay {
      display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6);
      z-index: 2000; justify-content: center; align-items: center;
    }
    .modal-overlay.active { display: flex; }

    .modal {
      background: #16213e; border-radius: 14px; padding: 28px;
      width: 380px; max-width: 90vw; border: 1px solid #0f3460;
      max-height: 90vh; overflow-y: auto;
    }
    .modal h2 { margin-bottom: 18px; font-size: 1.1rem; }

    .modal label {
      display: block; font-size: 0.8rem; color: #aaa; margin-bottom: 4px;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .modal input, .modal textarea {
      width: 100%; padding: 10px 12px; border-radius: 8px;
      border: 1px solid #0f3460; background: #1a1a2e; color: #eee;
      font-size: 0.95rem; margin-bottom: 14px; font-family: inherit;
    }
    .modal textarea { resize: vertical; min-height: 60px; }

    .modal .hint {
      font-size: 0.72rem; color: #666; margin-top: -10px; margin-bottom: 14px;
    }

    .category-grid {
      display: grid; grid-template-columns: 1fr 1fr 1fr;
      gap: 6px; margin-bottom: 14px;
    }
    .category-btn {
      padding: 8px 4px; border-radius: 8px; border: 2px solid transparent;
      cursor: pointer; font-size: 0.72rem; font-weight: 600;
      text-align: center; transition: all 0.15s; color: #fff;
    }
    .category-btn:hover { filter: brightness(1.15); }
    .category-btn.selected { border-color: #fff; transform: scale(1.04); }

    .modal-actions { display: flex; gap: 10px; margin-top: 6px; }
    .modal-actions .btn { flex: 1; padding: 10px; font-size: 0.95rem; }

    .btn-save { background: #e94560; color: #fff; }
    .btn-cancel { background: #0f3460; color: #eee; }
    .btn-delete { background: #6b2131; color: #fff; }

    /* MapLibre popup (tooltip style) */
    .maplibregl-popup-content {
      background: #16213e; color: #eee; border: 1px solid #0f3460;
      border-radius: 8px; padding: 8px 14px; font-size: 0.85rem;
      max-width: 260px; white-space: normal;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    .maplibregl-popup-tip {
      border-top-color: #16213e;
    }

    .toast {
      position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
      background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
      border-radius: 10px; padding: 10px 20px; z-index: 1000;
      font-size: 0.9rem; color: #ccc; pointer-events: none; transition: opacity 0.5s;
    }



    .search-box {
      position: absolute; top: 62px; right: 54px; z-index: 1000;
    }
    .search-box input {
      padding: 8px 14px; border-radius: 8px; border: 1px solid #0f3460;
      background: rgba(22,33,62,0.95); color: #eee; font-size: 0.9rem;
      width: 220px; font-family: inherit;
    }
    .search-box input::placeholder { color: #666; }

    /* Sidebar Panel */
    .sidebar-panel {
      position: absolute; top: 62px; left: 12px; z-index: 1000;
      background: rgba(22, 33, 62, 0.95); border-radius: 10px;
      border: 1px solid #0f3460; width: 260px;
      max-height: calc(100vh - 80px); display: flex; flex-direction: column;
    }
    .places-header {
      padding: 10px 14px 8px; border-bottom: 1px solid #0f3460;
      display: flex; align-items: center; justify-content: space-between;
      flex-shrink: 0;
    }
    .places-header h3 {
      font-size: 0.75rem; color: #aaa; text-transform: uppercase;
      letter-spacing: 1px; margin: 0;
    }
    .places-toggle {
      background: none; border: none; color: #aaa; cursor: pointer;
      font-size: 1rem; padding: 0 4px; transition: transform 0.2s;
    }
    .places-toggle.collapsed { transform: rotate(180deg); }
    .sidebar-content { display: flex; flex-direction: column; flex: 1; overflow: hidden; }
    .sidebar-content.collapsed { display: none; }
    .places-body {
      overflow-y: auto; padding: 6px 0; flex: 1;
    }
    .places-cat-header {
      padding: 6px 14px 3px; font-size: 0.7rem; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.8px;
      display: flex; align-items: center; gap: 6px;
      cursor: pointer; user-select: none;
    }
    .places-cat-header:hover { background: rgba(255,255,255,0.04); }
    .places-cat-chevron {
      margin-left: auto; font-size: 0.6rem; transition: transform 0.2s; color: #666;
    }
    .places-cat-chevron.collapsed { transform: rotate(-90deg); }
    .places-cat-dot {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
    }
    .places-cat-items { }
    .places-cat-items.collapsed { display: none; }
    .places-item {
      padding: 4px 14px 4px 28px; font-size: 0.8rem; cursor: pointer;
      transition: background 0.15s; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }
    .places-item:hover { background: rgba(255,255,255,0.07); }
    .places-item-notes {
      font-size: 0.68rem; color: #888; overflow: hidden;
      text-overflow: ellipsis; white-space: nowrap;
    }
    .places-empty {
      padding: 12px 14px; font-size: 0.8rem; color: #666; text-align: center;
    }

    /* Location bar (address search + GPS) */
    .locate-bar {
      position: absolute; top: 62px; left: 284px; z-index: 1000;
      display: flex; align-items: center; gap: 0;
      background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
      border-radius: 8px; overflow: hidden;
    }
    .locate-bar input {
      padding: 8px 12px; border: none; background: transparent; color: #eee;
      font-size: 0.82rem; font-family: inherit; width: 200px; outline: none;
    }
    .locate-bar input::placeholder { color: #666; }
    .locate-gps {
      background: none; border: none; border-left: 1px solid #0f3460;
      color: #aaa; cursor: pointer; padding: 7px 10px;
      display: flex; align-items: center; transition: color 0.2s, background 0.2s;
    }
    .locate-gps:hover { color: #60a5fa; background: rgba(255,255,255,0.05); }
    .locate-gps svg { flex-shrink: 0; }
    .user-loc-dot {
      width: 14px; height: 14px; border-radius: 50%;
      background: radial-gradient(circle at 40% 35%, #60a5fa, #2563eb);
      border: 2.5px solid #fff;
      box-shadow: 0 0 10px rgba(37,99,235,0.6);
    }

  </style>
</head>
<body>
  <header>
    <h1><span>Psychojelly</span> Recommendation Map</h1>
  </header>

  <div id="map"></div>
  <div class="search-box"><input type="text" id="search" placeholder="Search pins..." /></div>

  <!-- Sidebar: filters + places -->
  <div class="sidebar-panel" id="sidebar-panel">
    <div class="places-header">
      <h3>Places</h3>
      <button class="places-toggle" id="places-toggle" onclick="togglePlacesPanel()" title="Collapse">&#9650;</button>
    </div>
    <div class="sidebar-content" id="sidebar-content">
      <div class="legend-section">
        <div class="legend-section-header" onclick="toggleFilterSection()">
          <h3>Filter Categories</h3>
          <button class="legend-section-toggle" id="legend-toggle">&#9650;</button>
        </div>
        <div class="legend-grid" id="legend"></div>
      </div>
      <div class="places-body" id="places-body"></div>
    </div>
  </div>

  <!-- Location bar (address search + GPS) -->
  <div class="locate-bar">
    <input type="text" id="locate-input" placeholder="Search address or use GPS →" />
    <button class="locate-gps" id="locate-gps" onclick="goToMyLocation()" title="Use my GPS location">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>
    </button>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Edit Modal -->
  <div class="modal-overlay" id="edit-modal">
    <div class="modal">
      <h2>Edit Recommendation</h2>
      <label>Name</label>
      <input type="text" id="edit-name" />
      <label>Address</label>
      <input type="text" id="edit-address" placeholder="Address" />
      <p class="hint">Changing the address will update the pin's position.</p>
      <label>Category</label>
      <div class="category-grid" id="edit-category-grid"></div>
      <label>Notes</label>
      <textarea id="edit-notes"></textarea>
      <div class="modal-actions">
        <button class="btn btn-delete" onclick="deleteMarker()">Delete</button>
        <button class="btn btn-cancel" onclick="closeModal('edit-modal')">Cancel</button>
        <button class="btn btn-save" id="edit-save-btn" onclick="updateMarker()">Save</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // ── Categories ──
    const CATEGORIES = [
      { id: 'neighborhood', label: 'Neighborhoods',      color: '#94a3b8' },
      { id: 'coffee',       label: 'Coffee',             color: '#d97706' },
      { id: 'food',         label: 'Food',               color: '#e94560' },
      { id: 'drinks',       label: 'Bars & Nightlife',   color: '#f5a623' },
      { id: 'music',        label: 'Live Music',         color: '#a855f7' },
      { id: 'festival',     label: 'Festivals & Events', color: '#fbbf24' },
      { id: 'arts',         label: 'Arts & Culture',     color: '#f472b6' },
      { id: 'shopping',     label: 'Shopping & Records', color: '#ec4899' },
      { id: 'outdoors',     label: 'Outdoors & Nature',  color: '#4ecdc4' },
      { id: 'entertainment',label: 'Entertainment',      color: '#3b82f6' },
      { id: 'fitness',      label: 'Health & Wellness',  color: '#22c55e' },
      { id: 'daytrip',      label: 'Day Trips',          color: '#06b6d4' },
    ];

    // ── Helpers ──
    function hexToRgb(hex) {
      const n = parseInt(hex.replace('#', ''), 16);
      return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }
    function lightenColor(hex, pct) {
      const [r, g, b] = hexToRgb(hex);
      const f = pct / 100;
      return `rgb(${Math.round(r + (255 - r) * f)},${Math.round(g + (255 - g) * f)},${Math.round(b + (255 - b) * f)})`;
    }
    function darkenColor(hex, pct) {
      const [r, g, b] = hexToRgb(hex);
      const f = 1 - pct / 100;
      return `rgb(${Math.round(r * f)},${Math.round(g * f)},${Math.round(b * f)})`;
    }
    function debounce(fn, ms) {
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }

    // O(1) category lookup
    const CAT_MAP = new Map(CATEGORIES.map(c => [c.id, c]));
    const LOCATE_SVG = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>';

    // ── Canvas Pin Factory (renders pin images for WebGL symbol layer) ──
    function createPinCanvas(color) {
      const scale = 2;
      const canvas = document.createElement('canvas');
      canvas.width = 28 * scale;
      canvas.height = 40 * scale;
      const ctx = canvas.getContext('2d');
      ctx.scale(scale, scale);

      // Pin shape
      ctx.beginPath();
      ctx.moveTo(14, 0);
      ctx.bezierCurveTo(6.3, 0, 0, 6.3, 0, 14);
      ctx.bezierCurveTo(0, 24.5, 14, 40, 14, 40);
      ctx.bezierCurveTo(14, 40, 28, 24.5, 28, 14);
      ctx.bezierCurveTo(28, 6.3, 21.7, 0, 14, 0);
      ctx.closePath();

      // Radial gradient (cx=38%, cy=28%, r=60% of viewBox)
      const grad = ctx.createRadialGradient(10.64, 11.2, 0, 14, 14, 16.8);
      grad.addColorStop(0, lightenColor(color, 55));
      grad.addColorStop(0.5, color);
      grad.addColorStop(1, darkenColor(color, 40));
      ctx.fillStyle = grad;
      ctx.fill();

      // Stroke
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Highlight ellipse
      ctx.beginPath();
      ctx.ellipse(10.5, 10, 5, 3.5, 0, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fill();

      // Return {width, height, data} format for MapLibre addImage
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      return { width: canvas.width, height: canvas.height, data: new Uint8Array(imgData.data.buffer) };
    }

    // ── State ──
    let recommendations = [];
    let editingId = null;
    let editCategory = null;
    let markerClicked = false;
    let hiddenCategories = new Set(JSON.parse(localStorage.getItem('austin-recs-hidden') || '[]'));
    let searchQuery = '';

    // ── Geocoding via Nominatim (OpenStreetMap) ──
    const geocodeCache = JSON.parse(localStorage.getItem('austin-recs-geocache') || '{}');

    async function geocodeAddress(address) {
      if (!address) return null;
      if (geocodeCache[address]) return geocodeCache[address];
      const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1`;
      try {
        const resp = await fetch(url, {
          headers: { 'User-Agent': 'AustinRecMap/1.0' }
        });
        const data = await resp.json();
        if (data.length > 0) {
          const result = { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
          geocodeCache[address] = result;
          localStorage.setItem('austin-recs-geocache', JSON.stringify(geocodeCache));
          return result;
        }
      } catch (e) { console.warn('Geocoding failed for:', address, e); }
      return null;
    }

    async function geocodeMissing(recs) {
      const toGeocode = recs.filter(r => r.address && (isNaN(r.lat) || isNaN(r.lng)));
      if (toGeocode.length === 0) return;
      showToastMsg(`Geocoding ${toGeocode.length} address${toGeocode.length > 1 ? 'es' : ''}...`, toGeocode.length * 1200 + 2000);
      for (let i = 0; i < toGeocode.length; i++) {
        const rec = toGeocode[i];
        const result = await geocodeAddress(rec.address);
        if (result) {
          rec.lat = result.lat;
          rec.lng = result.lng;
        }
        if (i < toGeocode.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 1100));
        }
      }
      renderMarkers();
      showToastMsg('Geocoding complete!');
    }

    // ── CSV Parsing ──
    function parseCSVText(text) {
      const result = Papa.parse(text.trim(), {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
      });
      return result.data.map(row => ({
        id: (row.id || '').trim(),
        name: (row.name || '').trim(),
        category: (row.category || '').trim(),
        address: (row.address || '').trim(),
        lat: parseFloat(row.lat),
        lng: parseFloat(row.lng),
        notes: (row.notes || '').trim(),
      })).filter(r => r.name && ((!isNaN(r.lat) && !isNaN(r.lng)) || r.address));
    }

    // ── Load data from CSV on every startup ──
    async function loadData() {
      try {
        const resp = await fetch('data.csv?t=' + Date.now());
        if (!resp.ok) throw new Error('No CSV found');
        const text = await resp.text();
        recommendations = parseCSVText(text);
        renderMarkers();
        await geocodeMissing(recommendations);
      } catch (e) {
        console.warn('Could not load data.csv:', e);
        recommendations = [];
        renderMarkers();
      }
    }

    // ── Map (MapLibre GL with 3D) ──
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
      center: [-97.7431, 30.2672],
      zoom: 13,
      pitch: 50,
      bearing: -15,
      antialias: true,
      dragRotate: true,
      touchZoomRotate: true,
      touchPitch: true,
      maxPitch: 70,
    });

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true, showCompass: true }), 'top-right');

    // Shared popup for tooltip-style hover (offset accounts for pin height)
    const hoverPopup = new maplibregl.Popup({
      closeButton: false,
      closeOnClick: false,
      offset: [0, -44],
      anchor: 'bottom',
    });


    // ── 3D Buildings + Terrain + Globe (after style loads) ──
    map.on('load', () => {
      // Globe projection (v5+) — renders as sphere when zoomed out
      map.setProjection({ type: 'globe' });

      const style = map.getStyle();

      // Find the vector tile source from CARTO style
      let vectorSourceId = null;
      for (const [id, source] of Object.entries(style.sources)) {
        if (source.type === 'vector') { vectorSourceId = id; break; }
      }

      if (vectorSourceId) {
        // Remove existing flat building layers
        for (const layer of [...style.layers]) {
          if (layer['source-layer'] === 'building') {
            try { map.removeLayer(layer.id); } catch (e) {}
          }
        }

        // Find first symbol layer to insert buildings underneath labels
        let labelLayerId;
        for (const layer of style.layers) {
          if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
            labelLayerId = layer.id;
            break;
          }
        }

        // 3D building extrusions
        map.addLayer({
          id: '3d-buildings',
          source: vectorSourceId,
          'source-layer': 'building',
          type: 'fill-extrusion',
          minzoom: 13,
          paint: {
            'fill-extrusion-color': [
              'interpolate', ['linear'], ['coalesce', ['get', 'render_height'], 8],
              0, '#1e1e3a',
              30, '#262650',
              80, '#2e2e60'
            ],
            'fill-extrusion-height': ['coalesce', ['get', 'render_height'], 8],
            'fill-extrusion-base': ['coalesce', ['get', 'render_min_height'], 0],
            'fill-extrusion-opacity': 0.75,
          }
        }, labelLayerId);
      }

      // Terrain (elevation + hillshade)
      map.addSource('terrain-dem', {
        type: 'raster-dem',
        tiles: ['https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png'],
        encoding: 'terrarium',
        tileSize: 256,
        maxzoom: 15,
      });
      map.setTerrain({ source: 'terrain-dem', exaggeration: 3 });

      // Hillshade layer to visually emphasize terrain
      map.addLayer({
        id: 'hillshade',
        type: 'hillshade',
        source: 'terrain-dem',
        paint: {
          'hillshade-exaggeration': 0.6,
          'hillshade-shadow-color': '#000020',
          'hillshade-highlight-color': '#ffffff',
          'hillshade-illumination-direction': 315,
          'hillshade-accent-color': '#1a1a3e',
        }
      }, '3d-buildings');

      // Register pin images for each category (rendered via Canvas for WebGL)
      CATEGORIES.forEach(c => {
        map.addImage('pin-' + c.id, createPinCanvas(c.color), { pixelRatio: 2 });
      });

      // GeoJSON source + symbol layer — pins render in WebGL pipeline (no DOM desync)
      map.addSource('markers', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'markers-layer',
        type: 'symbol',
        source: 'markers',
        layout: {
          'icon-image': ['concat', 'pin-', ['get', 'category']],
          'icon-anchor': 'bottom',
          'icon-allow-overlap': true,
          'icon-ignore-placement': true,
        }
      });

      // Marker click → edit modal
      map.on('click', 'markers-layer', (e) => {
        markerClicked = true;
        openEditModal(e.features[0].properties.id);
      });

      // Marker hover → tooltip popup
      map.on('mouseenter', 'markers-layer', (e) => {
        map.getCanvas().style.cursor = 'pointer';
        const p = e.features[0].properties;
        const cat = CAT_MAP.get(p.category) || CATEGORIES[0];
        let html = `<strong>${p.name}</strong><br><em>${cat.label}</em>`;
        if (p.address) html += `<br><small>${p.address}</small>`;
        if (p.notes) html += `<br>${p.notes}`;
        hoverPopup.setLngLat(e.features[0].geometry.coordinates).setHTML(html).addTo(map);
      });
      map.on('mouseleave', 'markers-layer', () => {
        map.getCanvas().style.cursor = '';
        hoverPopup.remove();
      });

      // Load data after map is ready
      loadData();
    });

    // ── Toast ──
    function showToastMsg(msg, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = msg;
      toast.style.opacity = '1';
      clearTimeout(toast._timeout);
      toast._timeout = setTimeout(() => { toast.style.opacity = '0'; }, duration);
    }

    // ── Legend with toggles (skips rebuild if categories unchanged) ──
    let _lastLegendKey = '';
    function buildLegend() {
      const activeCats = new Set(recommendations.map(r => r.category));
      const key = [...activeCats].sort().join(',') + '|' + [...hiddenCategories].sort().join(',');
      if (key === _lastLegendKey) return;
      _lastLegendKey = key;
      const el = document.getElementById('legend');
      el.innerHTML = CATEGORIES.filter(c => activeCats.has(c.id)).map(c => {
        const disabled = hiddenCategories.has(c.id) ? ' disabled' : '';
        return `<div class="legend-item${disabled}" onclick="toggleCategory('${c.id}')">
          <div class="legend-dot" style="background:${c.color}"></div>
          ${c.label}
        </div>`;
      }).join('');
    }

    function toggleFilterSection() {
      const grid = document.getElementById('legend');
      const btn = document.getElementById('legend-toggle');
      grid.classList.toggle('collapsed');
      btn.classList.toggle('collapsed');
    }

    function toggleCategory(id) {
      if (hiddenCategories.has(id)) hiddenCategories.delete(id);
      else hiddenCategories.add(id);
      localStorage.setItem('austin-recs-hidden', JSON.stringify([...hiddenCategories]));
      buildLegend();
      renderMarkers();
    }

    // ── Category Buttons ──
    function buildCategoryButtons(containerId, onSelect) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      CATEGORIES.forEach(c => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'category-btn';
        btn.style.background = c.color;
        btn.textContent = c.label;
        btn.dataset.id = c.id;
        btn.addEventListener('click', () => {
          container.querySelectorAll('.category-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          onSelect(c.id);
        });
        container.appendChild(btn);
      });
    }
    buildCategoryButtons('edit-category-grid', id => { editCategory = id; });

    // ── Render Markers (WebGL symbol layer — no DOM desync) ──
    let visibleRecs = [];

    function renderMarkers() {
      visibleRecs = [];
      buildLegend();

      const q = searchQuery.toLowerCase();
      const features = [];

      for (let i = 0; i < recommendations.length; i++) {
        const rec = recommendations[i];
        if (isNaN(rec.lat) || isNaN(rec.lng)) continue;
        if (hiddenCategories.has(rec.category)) continue;
        if (q && !rec.name.toLowerCase().includes(q)
            && !(rec.notes || '').toLowerCase().includes(q)
            && !(rec.address || '').toLowerCase().includes(q)) continue;
        features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [rec.lng, rec.lat] },
          properties: { id: rec.id, name: rec.name, category: rec.category,
            address: rec.address || '', notes: rec.notes || '' }
        });
        visibleRecs.push(rec);
      }

      const source = map.getSource('markers');
      if (source) {
        source.setData({ type: 'FeatureCollection', features });
      }

      updatePlacesList();
    }

    // ── Places Sidebar ──
    function updatePlacesList() {
      const body = document.getElementById('places-body');
      if (!body) return;

      // Get map bounds to filter to visible pins
      const bounds = map.getBounds();
      const inView = visibleRecs.filter(r =>
        r.lat >= bounds.getSouth() && r.lat <= bounds.getNorth() &&
        r.lng >= bounds.getWest() && r.lng <= bounds.getEast()
      );

      if (inView.length === 0) {
        body.innerHTML = '<div class="places-empty">No places in view</div>';
        return;
      }

      // Group by category
      const groups = {};
      inView.forEach(rec => {
        if (!groups[rec.category]) groups[rec.category] = [];
        groups[rec.category].push(rec);
      });

      // Build HTML in category order (collapsible)
      let html = '';
      CATEGORIES.forEach(cat => {
        const recs = groups[cat.id];
        if (!recs || recs.length === 0) return;
        const collapsed = _collapsedPlacesCats.has(cat.id);
        html += `<div class="places-cat-header" style="color:${cat.color}" onclick="togglePlacesCat('${cat.id}')">
          <div class="places-cat-dot" style="background:${cat.color}"></div>
          ${cat.label} (${recs.length})
          <span class="places-cat-chevron${collapsed ? ' collapsed' : ''}">&#9660;</span>
        </div>`;
        html += `<div class="places-cat-items${collapsed ? ' collapsed' : ''}">`;
        recs.sort((a, b) => a.name.localeCompare(b.name)).forEach(rec => {
          html += `<div class="places-item" onclick="flyToPlace('${rec.id}')" title="${rec.notes || ''}">
            ${rec.name}
            ${rec.notes ? `<div class="places-item-notes">${rec.notes}</div>` : ''}
          </div>`;
        });
        html += `</div>`;
      });

      body.innerHTML = html;
    }

    function flyToPlace(id) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;
      map.flyTo({ center: [rec.lng, rec.lat], zoom: 16, duration: 800 });
    }

    const _collapsedPlacesCats = new Set();

    function togglePlacesCat(catId) {
      if (_collapsedPlacesCats.has(catId)) _collapsedPlacesCats.delete(catId);
      else _collapsedPlacesCats.add(catId);
      updatePlacesList();
    }

    function togglePlacesPanel() {
      const content = document.getElementById('sidebar-content');
      const btn = document.getElementById('places-toggle');
      content.classList.toggle('collapsed');
      btn.classList.toggle('collapsed');
    }

    // Update sidebar when map moves (debounced to avoid thrash during flyTo)
    map.on('moveend', debounce(updatePlacesList, 150));

    // ── Location (address search + GPS) ──
    let userLocationMarker = null;

    // Generate a GeoJSON circle polygon (~20 min walk = ~1600m)
    function walkRadiusCircle(center, radiusMeters) {
      const [lng, lat] = center;
      const R = 6371000;
      const coords = [];
      for (let i = 0; i <= 64; i++) {
        const a = (i / 64) * 2 * Math.PI;
        const dLat = (radiusMeters / R) * Math.cos(a) * (180 / Math.PI);
        const dLng = (radiusMeters / (R * Math.cos(lat * Math.PI / 180))) * Math.sin(a) * (180 / Math.PI);
        coords.push([lng + dLng, lat + dLat]);
      }
      return { type: 'Feature', geometry: { type: 'Polygon', coordinates: [coords] } };
    }

    // Shared: place dot + walk radius at a given location
    function setLocationOnMap(lng, lat) {
      if (userLocationMarker) userLocationMarker.remove();
      const dot = document.createElement('div');
      dot.className = 'user-loc-dot';
      userLocationMarker = new maplibregl.Marker({ element: dot, anchor: 'center' })
        .setLngLat([lng, lat]).addTo(map);

      const circle = walkRadiusCircle([lng, lat], 1600);
      if (map.getSource('walk-radius')) {
        map.getSource('walk-radius').setData(circle);
      } else {
        map.addSource('walk-radius', { type: 'geojson', data: circle });
        map.addLayer({
          id: 'walk-radius-fill',
          type: 'fill',
          source: 'walk-radius',
          paint: { 'fill-color': '#2563eb', 'fill-opacity': 0.08 }
        }, 'markers-layer');
        map.addLayer({
          id: 'walk-radius-line',
          type: 'line',
          source: 'walk-radius',
          paint: { 'line-color': '#60a5fa', 'line-width': 2, 'line-opacity': 0.5, 'line-dasharray': [3, 2] }
        }, 'markers-layer');
      }

      map.flyTo({ center: [lng, lat], zoom: 14, duration: 1200 });
    }

    // GPS button
    function goToMyLocation() {
      const btn = document.getElementById('locate-gps');
      btn.disabled = true;
      btn.style.opacity = '0.5';
      const reset = () => { btn.disabled = false; btn.style.opacity = ''; };

      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        reset();
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          setLocationOnMap(pos.coords.longitude, pos.coords.latitude);
          document.getElementById('locate-input').value = '';
          reset();
        },
        () => {
          alert('Could not get your location. Make sure location access is enabled.');
          reset();
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    // Address search (Enter key)
    document.getElementById('locate-input').addEventListener('keydown', async (e) => {
      if (e.key !== 'Enter') return;
      const address = e.target.value.trim();
      if (!address) return;

      e.target.disabled = true;
      e.target.placeholder = 'Searching...';
      const result = await geocodeAddress(address);
      e.target.disabled = false;
      e.target.placeholder = 'Search address or use GPS →';

      if (result) {
        setLocationOnMap(result.lng, result.lat);
      } else {
        alert('Could not find that address. Try a more specific address.');
      }
    });

    // ── Search (debounced — avoids re-rendering 120+ markers on every keystroke) ──
    document.getElementById('search').addEventListener('input', debounce((e) => {
      searchQuery = e.target.value.trim();
      renderMarkers();
    }, 200));

    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
      if (id === 'edit-modal') editingId = null;
    }

    // ── Edit ──
    function openEditModal(id) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;
      editingId = id;
      editCategory = rec.category;
      document.getElementById('edit-name').value = rec.name;
      document.getElementById('edit-address').value = rec.address || '';
      document.getElementById('edit-notes').value = rec.notes || '';
      document.querySelectorAll('#edit-category-grid .category-btn').forEach(b => {
        b.classList.toggle('selected', b.dataset.id === rec.category);
      });
      document.getElementById('edit-modal').classList.add('active');
    }

    async function updateMarker() {
      const rec = recommendations.find(r => r.id === editingId);
      if (!rec) return;
      const name = document.getElementById('edit-name').value.trim();
      const address = document.getElementById('edit-address').value.trim();
      if (!name) { alert('Please enter a name.'); return; }
      if (!editCategory) { alert('Please pick a category.'); return; }

      if (address && address !== (rec.address || '')) {
        const btn = document.getElementById('edit-save-btn');
        btn.textContent = 'Geocoding...';
        btn.disabled = true;
        const result = await geocodeAddress(address);
        btn.textContent = 'Save';
        btn.disabled = false;
        if (result) {
          rec.lat = result.lat;
          rec.lng = result.lng;
        }
      }

      rec.name = name;
      rec.address = address;
      rec.category = editCategory;
      rec.notes = document.getElementById('edit-notes').value.trim();
      renderMarkers(); closeModal('edit-modal');
    }

    function deleteMarker() {
      if (!confirm('Delete this recommendation?')) return;
      recommendations = recommendations.filter(r => r.id !== editingId);
      renderMarkers(); closeModal('edit-modal');
    }

    // ── Keyboard ──
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') { closeModal('edit-modal'); }
    });
  </script>
</body>
</html>
