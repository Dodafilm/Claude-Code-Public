<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Austin Rec Map</title>
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4/dist/maplibre-gl.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #1a1a2e;
      color: #eee;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      background: #16213e;
      border-bottom: 2px solid #0f3460;
      z-index: 1000;
      flex-wrap: wrap;
      gap: 8px;
    }

    header h1 { font-size: 1.3rem; font-weight: 700; letter-spacing: 1px; }
    header h1 span { color: #e94560; }

    .header-actions { display: flex; gap: 8px; flex-wrap: wrap; }

    .btn {
      padding: 6px 14px; border: none; border-radius: 6px; cursor: pointer;
      font-size: 0.85rem; font-weight: 600; transition: opacity 0.2s;
    }
    .btn:hover { opacity: 0.85; }
    .btn-primary { background: #0f3460; color: #eee; }
    .btn-danger  { background: #e94560; color: #fff; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    #map { flex: 1; z-index: 1; }

    /* Legend / Filter Panel */
    .legend {
      position: absolute; bottom: 30px; left: 12px;
      background: rgba(22, 33, 62, 0.95); border-radius: 10px;
      padding: 12px 16px; z-index: 1000; border: 1px solid #0f3460;
      max-width: 220px; max-height: 70vh; overflow-y: auto;
    }
    .legend h3 {
      font-size: 0.75rem; margin-bottom: 8px; color: #aaa;
      text-transform: uppercase; letter-spacing: 1px;
    }
    .legend-item {
      display: flex; align-items: center; gap: 8px;
      margin-bottom: 5px; font-size: 0.82rem; cursor: pointer;
      user-select: none; transition: opacity 0.2s;
    }
    .legend-item.disabled { opacity: 0.35; }
    .legend-dot {
      width: 14px; height: 14px; border-radius: 50%; flex-shrink: 0;
      border: 2px solid rgba(255,255,255,0.3);
    }

    /* Modal */
    .modal-overlay {
      display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6);
      z-index: 2000; justify-content: center; align-items: center;
    }
    .modal-overlay.active { display: flex; }

    .modal {
      background: #16213e; border-radius: 14px; padding: 28px;
      width: 380px; max-width: 90vw; border: 1px solid #0f3460;
      max-height: 90vh; overflow-y: auto;
    }
    .modal h2 { margin-bottom: 18px; font-size: 1.1rem; }

    .modal label {
      display: block; font-size: 0.8rem; color: #aaa; margin-bottom: 4px;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    .modal input, .modal textarea {
      width: 100%; padding: 10px 12px; border-radius: 8px;
      border: 1px solid #0f3460; background: #1a1a2e; color: #eee;
      font-size: 0.95rem; margin-bottom: 14px; font-family: inherit;
    }
    .modal textarea { resize: vertical; min-height: 60px; }

    .modal .hint {
      font-size: 0.72rem; color: #666; margin-top: -10px; margin-bottom: 14px;
    }

    .category-grid {
      display: grid; grid-template-columns: 1fr 1fr 1fr;
      gap: 6px; margin-bottom: 14px;
    }
    .category-btn {
      padding: 8px 4px; border-radius: 8px; border: 2px solid transparent;
      cursor: pointer; font-size: 0.72rem; font-weight: 600;
      text-align: center; transition: all 0.15s; color: #fff;
    }
    .category-btn:hover { filter: brightness(1.15); }
    .category-btn.selected { border-color: #fff; transform: scale(1.04); }

    .modal-actions { display: flex; gap: 10px; margin-top: 6px; }
    .modal-actions .btn { flex: 1; padding: 10px; font-size: 0.95rem; }

    .btn-save { background: #e94560; color: #fff; }
    .btn-cancel { background: #0f3460; color: #eee; }
    .btn-delete { background: #6b2131; color: #fff; }

    /* MapLibre popup (tooltip style) */
    .maplibregl-popup-content {
      background: #16213e; color: #eee; border: 1px solid #0f3460;
      border-radius: 8px; padding: 8px 14px; font-size: 0.85rem;
      max-width: 260px; white-space: normal;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    .maplibregl-popup-tip {
      border-top-color: #16213e;
    }

    .toast {
      position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
      background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
      border-radius: 10px; padding: 10px 20px; z-index: 1000;
      font-size: 0.9rem; color: #ccc; pointer-events: none; transition: opacity 0.5s;
    }

    #import-file { display: none; }

    .search-box {
      position: absolute; top: 62px; right: 54px; z-index: 1000;
    }
    .search-box input {
      padding: 8px 14px; border-radius: 8px; border: 1px solid #0f3460;
      background: rgba(22,33,62,0.95); color: #eee; font-size: 0.9rem;
      width: 220px; font-family: inherit;
    }
    .search-box input::placeholder { color: #666; }

    /* Places Sidebar */
    .places-panel {
      position: absolute; top: 62px; left: 12px; z-index: 1000;
      background: rgba(22, 33, 62, 0.95); border-radius: 10px;
      border: 1px solid #0f3460; width: 260px;
      max-height: calc(100vh - 170px); display: flex; flex-direction: column;
    }
    .places-header {
      padding: 10px 14px 8px; border-bottom: 1px solid #0f3460;
      display: flex; align-items: center; justify-content: space-between;
    }
    .places-header h3 {
      font-size: 0.75rem; color: #aaa; text-transform: uppercase;
      letter-spacing: 1px; margin: 0;
    }
    .places-toggle {
      background: none; border: none; color: #aaa; cursor: pointer;
      font-size: 1rem; padding: 0 4px; transition: transform 0.2s;
    }
    .places-toggle.collapsed { transform: rotate(180deg); }
    .places-body {
      overflow-y: auto; padding: 6px 0; flex: 1;
    }
    .places-body.collapsed { display: none; }
    .places-cat-header {
      padding: 6px 14px 3px; font-size: 0.7rem; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.8px;
      display: flex; align-items: center; gap: 6px;
    }
    .places-cat-dot {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
    }
    .places-item {
      padding: 4px 14px 4px 28px; font-size: 0.8rem; cursor: pointer;
      transition: background 0.15s; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }
    .places-item:hover { background: rgba(255,255,255,0.07); }
    .places-item-notes {
      font-size: 0.68rem; color: #888; overflow: hidden;
      text-overflow: ellipsis; white-space: nowrap;
    }
    .places-empty {
      padding: 12px 14px; font-size: 0.8rem; color: #666; text-align: center;
    }

    /* My Location button */
    .locate-btn {
      position: absolute; top: 62px; left: 284px; z-index: 1000;
      background: rgba(22, 33, 62, 0.95); border: 1px solid #0f3460;
      border-radius: 8px; padding: 7px 12px; color: #eee;
      cursor: pointer; font-size: 0.82rem; font-family: inherit;
      font-weight: 600; transition: background 0.2s;
      display: flex; align-items: center; gap: 6px;
    }
    .locate-btn:hover { background: rgba(15, 52, 96, 0.95); }
    .locate-btn svg { flex-shrink: 0; }
    .user-loc-dot {
      width: 14px; height: 14px; border-radius: 50%;
      background: radial-gradient(circle at 40% 35%, #60a5fa, #2563eb);
      border: 2.5px solid #fff;
      box-shadow: 0 0 10px rgba(37,99,235,0.6);
    }

  </style>
</head>
<body>
  <header>
    <h1><span>Austin</span> Rec Map</h1>
    <div class="header-actions">
      <button class="btn btn-primary" onclick="openAddByAddress()">+ Add by Address</button>
      <button class="btn btn-primary" onclick="document.getElementById('import-file').click()">Import CSV</button>
      <input type="file" id="import-file" accept=".csv,.json" />
      <button class="btn btn-primary" onclick="exportCSV()">Export CSV</button>
      <button class="btn btn-danger" onclick="resetToFile()">Reload CSV</button>
    </div>
  </header>

  <div id="map"></div>
  <div class="search-box"><input type="text" id="search" placeholder="Search pins..." /></div>

  <!-- Places sidebar -->
  <div class="places-panel" id="places-panel">
    <div class="places-header">
      <h3>Visible Places</h3>
      <button class="places-toggle" id="places-toggle" onclick="togglePlacesPanel()" title="Collapse">&#9650;</button>
    </div>
    <div class="places-body" id="places-body"></div>
  </div>

  <!-- My Location -->
  <button class="locate-btn" id="locate-btn" onclick="goToMyLocation()">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>
    My Location
  </button>

  <div class="legend" id="legend"></div>
  <div class="toast" id="toast">Click anywhere on the map to add a pin — or use + Add by Address</div>

  <!-- Add Modal -->
  <div class="modal-overlay" id="add-modal">
    <div class="modal">
      <h2>Add Recommendation</h2>
      <label>Name</label>
      <input type="text" id="rec-name" placeholder="e.g. Barton Springs Pool" />
      <label>Address</label>
      <input type="text" id="rec-address" placeholder="e.g. 1619 E 6th St, Austin, TX" />
      <p class="hint" id="add-location-hint"></p>
      <label>Category</label>
      <div class="category-grid" id="category-grid"></div>
      <label>Notes</label>
      <textarea id="rec-notes" placeholder="What makes it great?"></textarea>
      <div class="modal-actions">
        <button class="btn btn-cancel" onclick="closeModal('add-modal')">Cancel</button>
        <button class="btn btn-save" id="add-save-btn" onclick="saveMarker()">Save</button>
      </div>
    </div>
  </div>

  <!-- Edit Modal -->
  <div class="modal-overlay" id="edit-modal">
    <div class="modal">
      <h2>Edit Recommendation</h2>
      <label>Name</label>
      <input type="text" id="edit-name" />
      <label>Address</label>
      <input type="text" id="edit-address" placeholder="Address" />
      <p class="hint">Changing the address will update the pin's position.</p>
      <label>Category</label>
      <div class="category-grid" id="edit-category-grid"></div>
      <label>Notes</label>
      <textarea id="edit-notes"></textarea>
      <div class="modal-actions">
        <button class="btn btn-delete" onclick="deleteMarker()">Delete</button>
        <button class="btn btn-cancel" onclick="closeModal('edit-modal')">Cancel</button>
        <button class="btn btn-save" id="edit-save-btn" onclick="updateMarker()">Save</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@4/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // ── Categories ──
    const CATEGORIES = [
      { id: 'neighborhood', label: 'Neighborhoods',      color: '#94a3b8' },
      { id: 'coffee',       label: 'Coffee',             color: '#d97706' },
      { id: 'food',         label: 'Food',               color: '#e94560' },
      { id: 'drinks',       label: 'Bars & Nightlife',   color: '#f5a623' },
      { id: 'music',        label: 'Live Music',         color: '#a855f7' },
      { id: 'festival',     label: 'Festivals & Events', color: '#fbbf24' },
      { id: 'arts',         label: 'Arts & Culture',     color: '#f472b6' },
      { id: 'shopping',     label: 'Shopping & Records', color: '#ec4899' },
      { id: 'outdoors',     label: 'Outdoors & Nature',  color: '#4ecdc4' },
      { id: 'entertainment',label: 'Entertainment',      color: '#3b82f6' },
      { id: 'fitness',      label: 'Health & Wellness',  color: '#22c55e' },
      { id: 'daytrip',      label: 'Day Trips',          color: '#06b6d4' },
    ];

    // ── Helpers ──
    function hexToRgb(hex) {
      const n = parseInt(hex.replace('#', ''), 16);
      return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }
    function lightenColor(hex, pct) {
      const [r, g, b] = hexToRgb(hex);
      const f = pct / 100;
      return `rgb(${Math.round(r + (255 - r) * f)},${Math.round(g + (255 - g) * f)},${Math.round(b + (255 - b) * f)})`;
    }
    function darkenColor(hex, pct) {
      const [r, g, b] = hexToRgb(hex);
      const f = 1 - pct / 100;
      return `rgb(${Math.round(r * f)},${Math.round(g * f)},${Math.round(b * f)})`;
    }
    function debounce(fn, ms) {
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }

    // O(1) category lookup
    const CAT_MAP = new Map(CATEGORIES.map(c => [c.id, c]));
    const LOCATE_SVG = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>';

    // ── Canvas Pin Factory (renders pin images for WebGL symbol layer) ──
    function createPinCanvas(color) {
      const scale = 2;
      const canvas = document.createElement('canvas');
      canvas.width = 28 * scale;
      canvas.height = 40 * scale;
      const ctx = canvas.getContext('2d');
      ctx.scale(scale, scale);

      // Pin shape
      ctx.beginPath();
      ctx.moveTo(14, 0);
      ctx.bezierCurveTo(6.3, 0, 0, 6.3, 0, 14);
      ctx.bezierCurveTo(0, 24.5, 14, 40, 14, 40);
      ctx.bezierCurveTo(14, 40, 28, 24.5, 28, 14);
      ctx.bezierCurveTo(28, 6.3, 21.7, 0, 14, 0);
      ctx.closePath();

      // Radial gradient (cx=38%, cy=28%, r=60% of viewBox)
      const grad = ctx.createRadialGradient(10.64, 11.2, 0, 14, 14, 16.8);
      grad.addColorStop(0, lightenColor(color, 55));
      grad.addColorStop(0.5, color);
      grad.addColorStop(1, darkenColor(color, 40));
      ctx.fillStyle = grad;
      ctx.fill();

      // Stroke
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Highlight ellipse
      ctx.beginPath();
      ctx.ellipse(10.5, 10, 5, 3.5, 0, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fill();

      return canvas;
    }

    // ── State ──
    let recommendations = [];
    let pendingLatLng = null;
    let selectedCategory = null;
    let editingId = null;
    let editCategory = null;
    let markerClicked = false;
    let hiddenCategories = new Set(JSON.parse(localStorage.getItem('austin-recs-hidden') || '[]'));
    let searchQuery = '';

    // ── Geocoding via Nominatim (OpenStreetMap) ──
    const geocodeCache = JSON.parse(localStorage.getItem('austin-recs-geocache') || '{}');

    async function geocodeAddress(address) {
      if (!address) return null;
      if (geocodeCache[address]) return geocodeCache[address];
      const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1`;
      try {
        const resp = await fetch(url, {
          headers: { 'User-Agent': 'AustinRecMap/1.0' }
        });
        const data = await resp.json();
        if (data.length > 0) {
          const result = { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon) };
          geocodeCache[address] = result;
          localStorage.setItem('austin-recs-geocache', JSON.stringify(geocodeCache));
          return result;
        }
      } catch (e) { console.warn('Geocoding failed for:', address, e); }
      return null;
    }

    async function geocodeMissing(recs) {
      const toGeocode = recs.filter(r => r.address && (isNaN(r.lat) || isNaN(r.lng)));
      if (toGeocode.length === 0) return;
      showToastMsg(`Geocoding ${toGeocode.length} address${toGeocode.length > 1 ? 'es' : ''}...`, toGeocode.length * 1200 + 2000);
      for (let i = 0; i < toGeocode.length; i++) {
        const rec = toGeocode[i];
        const result = await geocodeAddress(rec.address);
        if (result) {
          rec.lat = result.lat;
          rec.lng = result.lng;
        }
        if (i < toGeocode.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 1100));
        }
      }
      save();
      renderMarkers();
      showToastMsg('Geocoding complete!');
    }

    // ── CSV Parsing ──
    function parseCSVText(text) {
      const result = Papa.parse(text.trim(), {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
      });
      return result.data.map(row => ({
        id: (row.id || '').trim(),
        name: (row.name || '').trim(),
        category: (row.category || '').trim(),
        address: (row.address || '').trim(),
        lat: parseFloat(row.lat),
        lng: parseFloat(row.lng),
        notes: (row.notes || '').trim(),
      })).filter(r => r.name && ((!isNaN(r.lat) && !isNaN(r.lng)) || r.address));
    }

    function toCSVText(data) {
      return Papa.unparse(data.map(r => ({
        id: r.id,
        name: r.name,
        category: r.category,
        address: r.address || '',
        lat: r.lat,
        lng: r.lng,
        notes: r.notes || '',
      })), { columns: ['id','name','category','address','lat','lng','notes'] });
    }

    // ── Load data: localStorage first, then fetch data.csv ──
    async function loadData() {
      const cached = localStorage.getItem('austin-recs-v3');
      if (cached) {
        recommendations = JSON.parse(cached);
        renderMarkers();
        return;
      }
      await loadFromCSVFile();
    }

    async function loadFromCSVFile() {
      try {
        const resp = await fetch('data.csv?t=' + Date.now());
        if (!resp.ok) throw new Error('No CSV found');
        const text = await resp.text();
        recommendations = parseCSVText(text);
        save();
        renderMarkers();
        await geocodeMissing(recommendations);
      } catch (e) {
        console.warn('Could not load data.csv:', e);
        recommendations = [];
        renderMarkers();
      }
    }

    // ── Persistence ──
    function save() {
      localStorage.setItem('austin-recs-v3', JSON.stringify(recommendations));
    }

    // ── Map (MapLibre GL with 3D) ──
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
      center: [-97.7431, 30.2672],
      zoom: 13,
      pitch: 50,
      bearing: -15,
      antialias: true,
      dragRotate: true,
      touchZoomRotate: true,
      touchPitch: true,
      maxPitch: 70,
    });

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true, showCompass: true }), 'top-right');

    // Shared popup for tooltip-style hover (offset accounts for pin height)
    const hoverPopup = new maplibregl.Popup({
      closeButton: false,
      closeOnClick: false,
      offset: [0, -44],
      anchor: 'bottom',
    });


    // ── 3D Buildings + Terrain (after style loads) ──
    map.on('load', () => {
      const style = map.getStyle();

      // Find the vector tile source from CARTO style
      let vectorSourceId = null;
      for (const [id, source] of Object.entries(style.sources)) {
        if (source.type === 'vector') { vectorSourceId = id; break; }
      }

      if (vectorSourceId) {
        // Remove existing flat building layers
        for (const layer of [...style.layers]) {
          if (layer['source-layer'] === 'building') {
            try { map.removeLayer(layer.id); } catch (e) {}
          }
        }

        // Find first symbol layer to insert buildings underneath labels
        let labelLayerId;
        for (const layer of style.layers) {
          if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
            labelLayerId = layer.id;
            break;
          }
        }

        // 3D building extrusions
        map.addLayer({
          id: '3d-buildings',
          source: vectorSourceId,
          'source-layer': 'building',
          type: 'fill-extrusion',
          minzoom: 13,
          paint: {
            'fill-extrusion-color': [
              'interpolate', ['linear'], ['coalesce', ['get', 'render_height'], 8],
              0, '#1e1e3a',
              30, '#262650',
              80, '#2e2e60'
            ],
            'fill-extrusion-height': ['coalesce', ['get', 'render_height'], 8],
            'fill-extrusion-base': ['coalesce', ['get', 'render_min_height'], 0],
            'fill-extrusion-opacity': 0.75,
          }
        }, labelLayerId);
      }

      // Terrain (elevation)
      map.addSource('terrain-dem', {
        type: 'raster-dem',
        tiles: ['https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png'],
        encoding: 'terrarium',
        tileSize: 256,
        maxzoom: 15,
      });
      map.setTerrain({ source: 'terrain-dem', exaggeration: 1.5 });

      // Register pin images for each category (rendered via Canvas for WebGL)
      CATEGORIES.forEach(c => {
        map.addImage('pin-' + c.id, createPinCanvas(c.color), { pixelRatio: 2 });
      });

      // GeoJSON source + symbol layer — pins render in WebGL pipeline (no DOM desync)
      map.addSource('markers', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'markers-layer',
        type: 'symbol',
        source: 'markers',
        layout: {
          'icon-image': ['concat', 'pin-', ['get', 'category']],
          'icon-anchor': 'bottom',
          'icon-allow-overlap': true,
          'icon-ignore-placement': true,
        }
      });

      // Marker click → edit modal
      map.on('click', 'markers-layer', (e) => {
        markerClicked = true;
        openEditModal(e.features[0].properties.id);
      });

      // Marker hover → tooltip popup
      map.on('mouseenter', 'markers-layer', (e) => {
        map.getCanvas().style.cursor = 'pointer';
        const p = e.features[0].properties;
        const cat = CAT_MAP.get(p.category) || CATEGORIES[0];
        let html = `<strong>${p.name}</strong><br><em>${cat.label}</em>`;
        if (p.address) html += `<br><small>${p.address}</small>`;
        if (p.notes) html += `<br>${p.notes}`;
        hoverPopup.setLngLat(e.features[0].geometry.coordinates).setHTML(html).addTo(map);
      });
      map.on('mouseleave', 'markers-layer', () => {
        map.getCanvas().style.cursor = '';
        hoverPopup.remove();
      });

      // Load data after map is ready
      loadData();
    });

    // ── Toast ──
    function showToastMsg(msg, duration = 3000) {
      const toast = document.getElementById('toast');
      toast.textContent = msg;
      toast.style.opacity = '1';
      clearTimeout(toast._timeout);
      toast._timeout = setTimeout(() => { toast.style.opacity = '0'; }, duration);
    }

    // ── Legend with toggles (skips rebuild if categories unchanged) ──
    let _lastLegendKey = '';
    function buildLegend() {
      const activeCats = new Set(recommendations.map(r => r.category));
      const key = [...activeCats].sort().join(',') + '|' + [...hiddenCategories].sort().join(',');
      if (key === _lastLegendKey) return;
      _lastLegendKey = key;
      const el = document.getElementById('legend');
      el.innerHTML = '<h3>Filter Categories</h3>' + CATEGORIES.filter(c => activeCats.has(c.id)).map(c => {
        const disabled = hiddenCategories.has(c.id) ? ' disabled' : '';
        return `<div class="legend-item${disabled}" data-cat="${c.id}" onclick="toggleCategory('${c.id}')">
          <div class="legend-dot" style="background:${c.color}"></div>
          ${c.label}
        </div>`;
      }).join('');
    }

    function toggleCategory(id) {
      if (hiddenCategories.has(id)) hiddenCategories.delete(id);
      else hiddenCategories.add(id);
      localStorage.setItem('austin-recs-hidden', JSON.stringify([...hiddenCategories]));
      buildLegend();
      renderMarkers();
    }

    // ── Category Buttons ──
    function buildCategoryButtons(containerId, onSelect) {
      const container = document.getElementById(containerId);
      container.innerHTML = '';
      CATEGORIES.forEach(c => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'category-btn';
        btn.style.background = c.color;
        btn.textContent = c.label;
        btn.dataset.id = c.id;
        btn.addEventListener('click', () => {
          container.querySelectorAll('.category-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          onSelect(c.id);
        });
        container.appendChild(btn);
      });
    }
    buildCategoryButtons('category-grid', id => { selectedCategory = id; });
    buildCategoryButtons('edit-category-grid', id => { editCategory = id; });

    // ── Render Markers (WebGL symbol layer — no DOM desync) ──
    let visibleRecs = [];

    function renderMarkers() {
      visibleRecs = [];
      buildLegend();

      const q = searchQuery.toLowerCase();
      const features = [];

      for (let i = 0; i < recommendations.length; i++) {
        const rec = recommendations[i];
        if (isNaN(rec.lat) || isNaN(rec.lng)) continue;
        if (hiddenCategories.has(rec.category)) continue;
        if (q && !rec.name.toLowerCase().includes(q)
            && !(rec.notes || '').toLowerCase().includes(q)
            && !(rec.address || '').toLowerCase().includes(q)) continue;
        features.push({
          type: 'Feature',
          geometry: { type: 'Point', coordinates: [rec.lng, rec.lat] },
          properties: { id: rec.id, name: rec.name, category: rec.category,
            address: rec.address || '', notes: rec.notes || '' }
        });
        visibleRecs.push(rec);
      }

      const source = map.getSource('markers');
      if (source) {
        source.setData({ type: 'FeatureCollection', features });
      }

      updatePlacesList();
    }

    // ── Places Sidebar ──
    function updatePlacesList() {
      const body = document.getElementById('places-body');
      if (!body) return;

      // Get map bounds to filter to visible pins
      const bounds = map.getBounds();
      const inView = visibleRecs.filter(r =>
        r.lat >= bounds.getSouth() && r.lat <= bounds.getNorth() &&
        r.lng >= bounds.getWest() && r.lng <= bounds.getEast()
      );

      if (inView.length === 0) {
        body.innerHTML = '<div class="places-empty">No places in view</div>';
        return;
      }

      // Group by category
      const groups = {};
      inView.forEach(rec => {
        if (!groups[rec.category]) groups[rec.category] = [];
        groups[rec.category].push(rec);
      });

      // Build HTML in category order
      let html = '';
      CATEGORIES.forEach(cat => {
        const recs = groups[cat.id];
        if (!recs || recs.length === 0) return;
        html += `<div class="places-cat-header" style="color:${cat.color}">
          <div class="places-cat-dot" style="background:${cat.color}"></div>
          ${cat.label} (${recs.length})
        </div>`;
        recs.sort((a, b) => a.name.localeCompare(b.name)).forEach(rec => {
          html += `<div class="places-item" onclick="flyToPlace('${rec.id}')" title="${rec.notes || ''}">
            ${rec.name}
            ${rec.notes ? `<div class="places-item-notes">${rec.notes}</div>` : ''}
          </div>`;
        });
      });

      body.innerHTML = html;
    }

    function flyToPlace(id) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;
      map.flyTo({ center: [rec.lng, rec.lat], zoom: 16, duration: 800 });
    }

    function togglePlacesPanel() {
      const body = document.getElementById('places-body');
      const btn = document.getElementById('places-toggle');
      body.classList.toggle('collapsed');
      btn.classList.toggle('collapsed');
    }

    // Update sidebar when map moves (debounced to avoid thrash during flyTo)
    map.on('moveend', debounce(updatePlacesList, 150));

    // ── My Location ──
    let userLocationMarker = null;

    function goToMyLocation() {
      const btn = document.getElementById('locate-btn');
      const resetBtn = () => { btn.innerHTML = LOCATE_SVG + ' My Location'; btn.disabled = false; };
      btn.textContent = 'Locating...';
      btn.disabled = true;

      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        resetBtn();
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          if (userLocationMarker) userLocationMarker.remove();
          const dot = document.createElement('div');
          dot.className = 'user-loc-dot';
          userLocationMarker = new maplibregl.Marker({ element: dot, anchor: 'center' })
            .setLngLat([longitude, latitude]).addTo(map);
          map.flyTo({ center: [longitude, latitude], zoom: 15, duration: 1200 });
          resetBtn();
        },
        () => {
          alert('Could not get your location. Make sure location access is enabled.');
          resetBtn();
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    // ── Search (debounced — avoids re-rendering 120+ markers on every keystroke) ──
    document.getElementById('search').addEventListener('input', debounce((e) => {
      searchQuery = e.target.value.trim();
      renderMarkers();
    }, 200));

    // ── Map Click → Add ──
    map.on('click', (e) => {
      if (markerClicked) { markerClicked = false; return; }
      pendingLatLng = { lat: e.lngLat.lat, lng: e.lngLat.lng };
      selectedCategory = null;
      document.getElementById('rec-name').value = '';
      document.getElementById('rec-address').value = '';
      document.getElementById('rec-notes').value = '';
      document.getElementById('add-location-hint').textContent = 'Pin placed at clicked location. Address is optional (for display).';
      document.querySelectorAll('#category-grid .category-btn').forEach(b => b.classList.remove('selected'));
      document.getElementById('add-modal').classList.add('active');
      setTimeout(() => document.getElementById('rec-name').focus(), 100);
    });

    // ── Add by Address ──
    function openAddByAddress() {
      pendingLatLng = null;
      selectedCategory = null;
      document.getElementById('rec-name').value = '';
      document.getElementById('rec-address').value = '';
      document.getElementById('rec-notes').value = '';
      document.getElementById('add-location-hint').textContent = 'Address will be geocoded to place the pin on the map.';
      document.querySelectorAll('#category-grid .category-btn').forEach(b => b.classList.remove('selected'));
      document.getElementById('add-modal').classList.add('active');
      setTimeout(() => document.getElementById('rec-address').focus(), 100);
    }

    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
      if (id === 'add-modal') pendingLatLng = null;
      if (id === 'edit-modal') editingId = null;
    }

    async function saveMarker() {
      const name = document.getElementById('rec-name').value.trim();
      const address = document.getElementById('rec-address').value.trim();
      if (!name) { alert('Please enter a name.'); return; }
      if (!selectedCategory) { alert('Please pick a category.'); return; }

      let lat, lng;
      if (pendingLatLng) {
        lat = pendingLatLng.lat;
        lng = pendingLatLng.lng;
      } else if (address) {
        const btn = document.getElementById('add-save-btn');
        btn.textContent = 'Geocoding...';
        btn.disabled = true;
        const result = await geocodeAddress(address);
        btn.textContent = 'Save';
        btn.disabled = false;
        if (!result) {
          alert('Could not geocode that address. Try a more specific address, or add the pin by clicking the map.');
          return;
        }
        lat = result.lat;
        lng = result.lng;
      } else {
        alert('Please enter an address, or close this and click the map to place a pin.');
        return;
      }

      recommendations.push({
        id: Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
        name, category: selectedCategory, address,
        notes: document.getElementById('rec-notes').value.trim(),
        lat, lng,
      });
      save(); renderMarkers(); closeModal('add-modal');
    }

    // ── Edit ──
    function openEditModal(id) {
      const rec = recommendations.find(r => r.id === id);
      if (!rec) return;
      editingId = id;
      editCategory = rec.category;
      document.getElementById('edit-name').value = rec.name;
      document.getElementById('edit-address').value = rec.address || '';
      document.getElementById('edit-notes').value = rec.notes || '';
      document.querySelectorAll('#edit-category-grid .category-btn').forEach(b => {
        b.classList.toggle('selected', b.dataset.id === rec.category);
      });
      document.getElementById('edit-modal').classList.add('active');
    }

    async function updateMarker() {
      const rec = recommendations.find(r => r.id === editingId);
      if (!rec) return;
      const name = document.getElementById('edit-name').value.trim();
      const address = document.getElementById('edit-address').value.trim();
      if (!name) { alert('Please enter a name.'); return; }
      if (!editCategory) { alert('Please pick a category.'); return; }

      if (address && address !== (rec.address || '')) {
        const btn = document.getElementById('edit-save-btn');
        btn.textContent = 'Geocoding...';
        btn.disabled = true;
        const result = await geocodeAddress(address);
        btn.textContent = 'Save';
        btn.disabled = false;
        if (result) {
          rec.lat = result.lat;
          rec.lng = result.lng;
        }
      }

      rec.name = name;
      rec.address = address;
      rec.category = editCategory;
      rec.notes = document.getElementById('edit-notes').value.trim();
      save(); renderMarkers(); closeModal('edit-modal');
    }

    function deleteMarker() {
      if (!confirm('Delete this recommendation?')) return;
      recommendations = recommendations.filter(r => r.id !== editingId);
      save(); renderMarkers(); closeModal('edit-modal');
    }

    // ── Export CSV ──
    function exportCSV() {
      const csv = toCSVText(recommendations);
      const blob = new Blob([csv], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'data.csv';
      a.click();
    }

    // ── Import CSV ──
    document.getElementById('import-file').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async (ev) => {
        try {
          const text = ev.target.result;
          if (file.name.endsWith('.json')) {
            const data = JSON.parse(text);
            if (Array.isArray(data)) recommendations = data;
          } else {
            recommendations = parseCSVText(text);
          }
          save(); renderMarkers();
          await geocodeMissing(recommendations);
        } catch { alert('Could not parse file.'); }
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    // ── Reload from data.csv ──
    function resetToFile() {
      if (!confirm('Reload from data.csv? This will discard any pins you added in the browser.')) return;
      localStorage.removeItem('austin-recs-v3');
      loadFromCSVFile();
    }

    // ── Keyboard ──
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') { closeModal('add-modal'); closeModal('edit-modal'); }
    });

    // ── Toast auto-hide ──
    setTimeout(() => { document.getElementById('toast').style.opacity = '0'; }, 5000);
  </script>
</body>
</html>
