<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>3D Boid Simulation</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; touch-action: none; }
  canvas { display: block; touch-action: none; }
  #hud {
    position: fixed; top: 10px; left: 10px;
    color: rgba(255,255,255,0.7); font-size: 13px; line-height: 1.6;
    pointer-events: none; user-select: none;
  }
  #hud span { color: #0ff; }
  #touch-controls {
    display: none;
    position: fixed; bottom: 16px; left: 0; right: 0;
    justify-content: center; gap: 10px;
    pointer-events: none; user-select: none; z-index: 10;
  }
  #touch-controls button {
    pointer-events: auto;
    width: 52px; height: 52px; border-radius: 50%;
    border: 1.5px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.08);
    color: #fff; font-size: 18px; font-family: inherit;
    backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
    cursor: pointer; display: flex; align-items: center; justify-content: center;
  }
  #touch-controls button:active { background: rgba(255,255,255,0.25); }
  #touch-hint {
    display: none;
    position: fixed; bottom: 78px; left: 0; right: 0;
    text-align: center; color: rgba(255,255,255,0.4); font-size: 11px;
    pointer-events: none; user-select: none;
  }
  #social-slider-wrap {
    position: fixed; top: 10px; left: 170px;
    display: flex; align-items: center; gap: 6px;
    z-index: 10; user-select: none;
  }
  #social-slider-wrap label {
    color: rgba(255,255,255,0.5); font-size: 11px; font-family: 'Courier New', monospace;
    white-space: nowrap;
  }
  #social-slider {
    -webkit-appearance: none; appearance: none;
    width: 140px; height: 4px; border-radius: 2px;
    background: linear-gradient(to right, #f06030, #333 40%, #333 60%, #30c0f0);
    outline: none; cursor: pointer;
  }
  #social-slider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 14px; height: 14px; border-radius: 50%;
    background: #fff; border: 1.5px solid rgba(255,255,255,0.4);
    box-shadow: 0 0 6px rgba(255,255,255,0.3);
  }
  #social-slider::-moz-range-thumb {
    width: 14px; height: 14px; border-radius: 50%;
    background: #fff; border: 1.5px solid rgba(255,255,255,0.4);
    box-shadow: 0 0 6px rgba(255,255,255,0.3);
  }
</style>
</head>
<body>
<div id="hud">
  FPS: <span id="fpsDisplay">0</span><br>
  Boids: <span id="countDisplay">150</span><br>
  Speed: <span id="speedDisplay">1.00</span>x<br>
  Rotation: <span id="rotDisplay">0.0</span>&deg;<br>
  Zoom: <span id="zoomDisplay">1.00</span>x<br>
  Social: <span id="socialDisplay">0.00</span><br>
  Cursor: <span id="cursorDisplay">0, 0</span><br><br>
  <small id="desktop-hints">
    Arrow Up/Down &mdash; speed<br>
    Arrow Left/Right &mdash; rotate<br>
    Page Up/Down &mdash; zoom<br>
    +/&minus; &mdash; add/remove boids<br>
    Mouse &mdash; attract | Click &mdash; repel
  </small>
  <small id="mobile-hints" style="display:none">
    Drag &mdash; attract | Long press &mdash; repel<br>
    Two-finger rotate &mdash; pinch to zoom
  </small>
</div>
<div id="touch-controls">
  <button id="btn-slower" aria-label="Slower">&#9661;</button>
  <button id="btn-faster" aria-label="Faster">&#9651;</button>
  <button id="btn-fewer" aria-label="Fewer boids">&minus;</button>
  <button id="btn-more" aria-label="More boids">+</button>
</div>
<div id="touch-hint">Drag to attract &bull; Long press to repel</div>
<div id="social-slider-wrap">
  <label id="social-label-repel">repel</label>
  <input type="range" id="social-slider" min="-100" max="100" value="0" step="1">
  <label id="social-label-attract">attract</label>
</div>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;

// Offscreen canvas for volumetric fog (half res for performance)
const fogCanvas = document.createElement('canvas');
const fogCtx = fogCanvas.getContext('2d');
let fogW, fogH;
const FOG_SCALE = 0.5;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  fogW = fogCanvas.width = Math.ceil(W * FOG_SCALE);
  fogH = fogCanvas.height = Math.ceil(H * FOG_SCALE);
}
resize();
window.addEventListener('resize', resize);

// --- State ---
let boids = [];
let speedMultiplier = 1.0;
let rotationY = 0;        // radians
let rotationVel = 0;
let mouseX = W / 2, mouseY = H / 2;
let mouseDown = false;
let targetCount = 150;
let socialForce = 0; // -1 (repel) to +1 (attract)
let zoom = 1.0;           // 0.3 to 3.0

const BOUNDS = 400;        // 3D cube half-size
const FOV = 600;
const MAX_SPEED = 4;
const VISUAL_RANGE = 80;
const SEPARATION_DIST = 30;

// --- Boid ---
function createBoid(x, y, z) {
  return {
    x: x ?? (Math.random() - 0.5) * BOUNDS * 2,
    y: y ?? (Math.random() - 0.5) * BOUNDS * 2,
    z: z ?? (Math.random() - 0.5) * BOUNDS * 2,
    vx: (Math.random() - 0.5) * 2,
    vy: (Math.random() - 0.5) * 2,
    vz: (Math.random() - 0.5) * 2,
    hue: Math.random() * 360,
  };
}

for (let i = 0; i < targetCount; i++) boids.push(createBoid());

// --- Projection ---
function rotateYAxis(x, y, z, angle) {
  const c = Math.cos(angle), s = Math.sin(angle);
  return { x: x * c + z * s, y, z: -x * s + z * c };
}

function project(x, y, z) {
  const r = rotateYAxis(x, y, z, rotationY);
  const perspective = zoom * FOV / (FOV + r.z + BOUNDS * 1.5);
  return {
    sx: W / 2 + r.x * perspective,
    sy: H / 2 + r.y * perspective,
    depth: r.z,
    scale: perspective,
  };
}

// --- Unproject mouse into 3D (on z=0 plane after rotation) ---
function unprojectMouse(mx, my) {
  const perspective = FOV / (FOV + BOUNDS * 1.5);
  const wx = (mx - W / 2) / perspective;
  const wy = (my - H / 2) / perspective;
  const c = Math.cos(-rotationY), s = Math.sin(-rotationY);
  return { x: wx * c, y: wy, z: -wx * s };
}

// --- Boid rules ---
function updateBoids(dt) {
  const mouse3D = unprojectMouse(mouseX, mouseY);
  const n = boids.length;

  for (let i = 0; i < n; i++) {
    const b = boids[i];
    let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;
    let aliX = 0, aliY = 0, aliZ = 0, aliCount = 0;
    let sepX = 0, sepY = 0, sepZ = 0;

    for (let j = 0; j < n; j++) {
      if (i === j) continue;
      const o = boids[j];
      const dx = o.x - b.x, dy = o.y - b.y, dz = o.z - b.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

      if (dist < VISUAL_RANGE) {
        cohX += o.x; cohY += o.y; cohZ += o.z;
        cohCount++;
        aliX += o.vx; aliY += o.vy; aliZ += o.vz;
        aliCount++;
      }
      if (dist < SEPARATION_DIST && dist > 0) {
        sepX -= dx / dist;
        sepY -= dy / dist;
        sepZ -= dz / dist;
      }
    }

    // Cohesion — socialForce scales from -1 (anti-cohere) to 3x at full attract
    const cohScale = 0.005 * (1 + socialForce * 2);
    if (cohCount > 0) {
      cohX = (cohX / cohCount - b.x) * cohScale;
      cohY = (cohY / cohCount - b.y) * cohScale;
      cohZ = (cohZ / cohCount - b.z) * cohScale;
    }

    // Alignment
    if (aliCount > 0) {
      aliX = (aliX / aliCount - b.vx) * 0.04;
      aliY = (aliY / aliCount - b.vy) * 0.04;
      aliZ = (aliZ / aliCount - b.vz) * 0.04;
    }

    // Separation — socialForce scales from 2x at full repel to 0 at full attract
    const sepScale = 0.15 * (1 - socialForce);
    sepX *= sepScale;
    sepY *= sepScale;
    sepZ *= sepScale;

    // Mouse attraction / repulsion
    const mdx = mouse3D.x - b.x;
    const mdy = mouse3D.y - b.y;
    const mdz = mouse3D.z - b.z;
    const mDist = Math.sqrt(mdx * mdx + mdy * mdy + mdz * mdz) || 1;
    const mouseForce = mouseDown ? -0.12 : 0.03;
    const repelFalloff = mouseDown ? Math.min(1, 300 / (mDist + 1)) : 1;
    const mfx = (mdx / mDist) * mouseForce * repelFalloff;
    const mfy = (mdy / mDist) * mouseForce * repelFalloff;
    const mfz = (mdz / mDist) * mouseForce * repelFalloff;

    // Boundary nudge
    let bndX = 0, bndY = 0, bndZ = 0;
    const margin = BOUNDS * 0.8;
    const turnFactor = 0.15;
    if (b.x > margin)  bndX -= turnFactor;
    if (b.x < -margin) bndX += turnFactor;
    if (b.y > margin)  bndY -= turnFactor;
    if (b.y < -margin) bndY += turnFactor;
    if (b.z > margin)  bndZ -= turnFactor;
    if (b.z < -margin) bndZ += turnFactor;

    // Apply forces
    b.vx += (cohX + aliX + sepX + mfx + bndX) * dt;
    b.vy += (cohY + aliY + sepY + mfy + bndY) * dt;
    b.vz += (cohZ + aliZ + sepZ + mfz + bndZ) * dt;

    // Limit speed
    const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy + b.vz * b.vz);
    const limit = MAX_SPEED * speedMultiplier;
    if (spd > limit) {
      b.vx = (b.vx / spd) * limit;
      b.vy = (b.vy / spd) * limit;
      b.vz = (b.vz / spd) * limit;
    }
    // Enforce minimum speed
    const minSpd = limit * 0.3;
    if (spd < minSpd && spd > 0) {
      b.vx = (b.vx / spd) * minSpd;
      b.vy = (b.vy / spd) * minSpd;
      b.vz = (b.vz / spd) * minSpd;
    }

    b.x += b.vx * dt * speedMultiplier;
    b.y += b.vy * dt * speedMultiplier;
    b.z += b.vz * dt * speedMultiplier;

    // Shift hue slowly based on speed
    b.hue = (b.hue + spd * 0.05 * dt) % 360;
  }
}

// --- Lighting ---
const LIGHT_RADIUS = 800;       // falloff distance in 3D
const AMBIENT = 0.12;           // global illumination base
const GI_BOUNCE = 0.08;         // simulated bounce light
const LIGHT_INTENSITY = 1.4;

function hslToRgb(h, s, l) {
  s /= 100; l /= 100;
  const k = n => (n + h / 30) % 12;
  const a = s * Math.min(l, 1 - l);
  const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
  return [f(0) * 255, f(8) * 255, f(4) * 255];
}

// --- Projected wall shadows (boid shadows cast onto wall surfaces) ---
function drawWallShadows(light3D) {
  const B = BOUNDS;
  const walls = [
    { axis: 0, val: B },  { axis: 0, val: -B },
    { axis: 1, val: B },  { axis: 1, val: -B },
    { axis: 2, val: B },  { axis: 2, val: -B },
  ];
  const getAxis = (b, a) => a === 0 ? b.x : a === 1 ? b.y : b.z;
  const getLAxis = (l, a) => a === 0 ? l.x : a === 1 ? l.y : l.z;

  for (const wall of walls) {
    for (const b of boids) {
      const bVal = getAxis(b, wall.axis);
      const lVal = getLAxis(light3D, wall.axis);
      const denom = bVal - lVal;
      if (Math.abs(denom) < 0.1) continue;

      const t = (wall.val - lVal) / denom;
      if (t < 1 || t > 20) continue; // shadow must be beyond boid, cap range

      const sx = light3D.x + t * (b.x - light3D.x);
      const sy = light3D.y + t * (b.y - light3D.y);
      const sz = light3D.z + t * (b.z - light3D.z);

      if (Math.abs(sx) > B + 5 || Math.abs(sy) > B + 5 || Math.abs(sz) > B + 5) continue;

      const p = project(sx, sy, sz);
      const shadowDist = t - 1; // how far shadow is from boid (0 = contact)
      const shadowSize = Math.max(3, 8 * p.scale * (1 + shadowDist * 0.8));
      const shadowAlpha = Math.min(0.55, 0.6 / (1 + shadowDist * 1.5));

      // Draw soft shadow blob
      const grad = ctx.createRadialGradient(p.sx, p.sy, 0, p.sx, p.sy, shadowSize);
      grad.addColorStop(0, `rgba(0, 0, 0, ${shadowAlpha})`);
      grad.addColorStop(0.6, `rgba(0, 0, 0, ${shadowAlpha * 0.4})`);
      grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, shadowSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// --- Soft shadow volumes (atmospheric darkening on walls) ---
function drawShadowVolumes(sorted) {
  fogCtx.fillStyle = '#fff';
  fogCtx.fillRect(0, 0, fogW, fogH);

  const fmx = mouseX * FOG_SCALE;
  const fmy = mouseY * FOG_SCALE;
  const maxR = Math.max(fogW, fogH) * 0.95;

  for (const { b, sx, sy, scale } of sorted) {
    const bx = sx * FOG_SCALE;
    const by = sy * FOG_SCALE;
    const dx = bx - fmx;
    const dy = by - fmy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) continue;

    const nx = dx / dist;
    const ny = dy / dist;
    const px = -ny;
    const py = nx;

    const boidWidth = Math.max(2.5, 7 * scale) * FOG_SCALE;
    const shadowLen = maxR * 1.2;
    const spread = 2.5;

    const n1x = bx + px * boidWidth;
    const n1y = by + py * boidWidth;
    const n2x = bx - px * boidWidth;
    const n2y = by - py * boidWidth;

    const f1x = bx + nx * shadowLen + px * boidWidth * spread;
    const f1y = by + ny * shadowLen + py * boidWidth * spread;
    const f2x = bx + nx * shadowLen - px * boidWidth * spread;
    const f2y = by + ny * shadowLen - py * boidWidth * spread;

    const shadowAlpha = Math.min(0.5, Math.max(0.08, scale * 0.45));

    fogCtx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
    fogCtx.beginPath();
    fogCtx.moveTo(n1x, n1y);
    fogCtx.lineTo(f1x, f1y);
    fogCtx.lineTo(f2x, f2y);
    fogCtx.lineTo(n2x, n2y);
    fogCtx.closePath();
    fogCtx.fill();
  }

  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  ctx.drawImage(fogCanvas, 0, 0, W, H);
  ctx.restore();
}

function drawCursorOrb() {
  ctx.save();
  const repel = mouseDown;

  // Soft colored glow (visible on white walls)
  const g1 = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, repel ? 100 : 80);
  g1.addColorStop(0, repel ? 'rgba(255, 80, 40, 0.35)' : 'rgba(50, 140, 255, 0.3)');
  g1.addColorStop(0.5, repel ? 'rgba(255, 40, 10, 0.12)' : 'rgba(30, 90, 220, 0.1)');
  g1.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = g1;
  const outerR = repel ? 100 : 80;
  ctx.fillRect(mouseX - outerR, mouseY - outerR, outerR * 2, outerR * 2);

  // Core
  const g2 = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 10);
  g2.addColorStop(0, repel ? 'rgba(255, 120, 60, 0.9)' : 'rgba(80, 160, 255, 0.85)');
  g2.addColorStop(0.6, repel ? 'rgba(200, 50, 20, 0.4)' : 'rgba(40, 100, 220, 0.35)');
  g2.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = g2;
  ctx.beginPath();
  ctx.arc(mouseX, mouseY, 10, 0, Math.PI * 2);
  ctx.fill();

  // Center dot
  ctx.fillStyle = repel ? 'rgba(255, 200, 160, 0.95)' : 'rgba(200, 230, 255, 0.95)';
  ctx.beginPath();
  ctx.arc(mouseX, mouseY, 3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawBoid(b, light3D) {
  const p = project(b.x, b.y, b.z);
  if (p.scale <= 0) return;

  const size = Math.max(2.5, 7 * p.scale);

  // --- Light vector ---
  const lx = light3D.x - b.x, ly = light3D.y - b.y, lz = light3D.z - b.z;
  const lightDist = Math.sqrt(lx * lx + ly * ly + lz * lz) || 1;
  const lnx = lx / lightDist, lny = ly / lightDist, lnz = lz / lightDist;

  // Distance attenuation
  const attenuation = Math.min(1, LIGHT_RADIUS * LIGHT_RADIUS / (lightDist * lightDist + 200));

  // Boid forward direction (velocity normalized)
  const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy + b.vz * b.vz) || 1;
  const fwdX = b.vx / spd, fwdY = b.vy / spd, fwdZ = b.vz / spd;

  // Build a local coordinate frame for the boid
  // "up" = cross(forward, arbitrary) to get a wing axis
  let upX = 0, upY = -1, upZ = 0;
  // Wing axis = cross(forward, up)
  let wingX = fwdY * upZ - fwdZ * upY;
  let wingY = fwdZ * upX - fwdX * upZ;
  let wingZ = fwdX * upY - fwdY * upX;
  const wLen = Math.sqrt(wingX * wingX + wingY * wingY + wingZ * wingZ) || 1;
  wingX /= wLen; wingY /= wLen; wingZ /= wLen;
  // Recompute up = cross(wing, forward)
  upX = wingY * fwdZ - wingZ * fwdY;
  upY = wingZ * fwdX - wingX * fwdZ;
  upZ = wingX * fwdY - wingY * fwdX;

  // --- Per-face normals ---
  // Left wing face normal: cross(forward, wing+up)
  const leftNx = fwdY * (wingZ + upZ) - fwdZ * (wingY + upY);
  const leftNy = fwdZ * (wingX + upX) - fwdX * (wingZ + upZ);
  const leftNz = fwdX * (wingY + upY) - fwdY * (wingX + upX);
  const leftLen = Math.sqrt(leftNx*leftNx + leftNy*leftNy + leftNz*leftNz) || 1;

  const rightNx = -leftNx, rightNy = -leftNy, rightNz = -leftNz;

  // Top face normal ~= up
  const topNx = upX, topNy = upY, topNz = upZ;

  // Diffuse per face
  const diffLeft  = Math.max(0, (leftNx/leftLen)*lnx + (leftNy/leftLen)*lny + (leftNz/leftLen)*lnz);
  const diffRight = Math.max(0, (rightNx/leftLen)*lnx + (rightNy/leftLen)*lny + (rightNz/leftLen)*lnz);
  const diffTop   = Math.max(0, topNx*lnx + topNy*lny + topNz*lnz);

  // Specular per face (Blinn-Phong)
  // View direction approx: towards camera (0,0,-1) in rotated space
  const viewZ = -1;
  const halfX = lnx, halfY = lny, halfZ = (lnz + viewZ);
  const hLen = Math.sqrt(halfX*halfX + halfY*halfY + halfZ*halfZ) || 1;
  const hnx = halfX/hLen, hny = halfY/hLen, hnz = halfZ/hLen;
  const specLeft  = Math.pow(Math.max(0, (leftNx/leftLen)*hnx + (leftNy/leftLen)*hny + (leftNz/leftLen)*hnz), 32) * attenuation;
  const specRight = Math.pow(Math.max(0, (rightNx/leftLen)*hnx + (rightNy/leftLen)*hny + (rightNz/leftLen)*hnz), 32) * attenuation;
  const specTop   = Math.pow(Math.max(0, topNx*hnx + topNy*hny + topNz*hnz), 32) * attenuation;

  // Brightness per face
  const bLeft  = Math.min(1, AMBIENT + GI_BOUNCE + diffLeft  * LIGHT_INTENSITY * attenuation);
  const bRight = Math.min(1, AMBIENT + GI_BOUNCE + diffRight * LIGHT_INTENSITY * attenuation);
  const bTop   = Math.min(1, AMBIENT + GI_BOUNCE + diffTop   * LIGHT_INTENSITY * attenuation);

  // Base color
  const [baseR, baseG, baseB] = hslToRgb(b.hue, 85, 45);
  const alpha = Math.min(1, 0.5 + p.scale * 0.6);

  // Color per face
  function faceColor(brightness, spec) {
    const r = Math.min(255, baseR * brightness + spec * 220 + attenuation * 25) | 0;
    const g = Math.min(255, baseG * brightness + spec * 230 + attenuation * 30) | 0;
    const bl = Math.min(255, baseB * brightness + spec * 255 + attenuation * 35) | 0;
    return `rgba(${r}, ${g}, ${bl}, ${alpha})`;
  }

  // Screen-space vertices
  const vr = rotateYAxis(b.vx, b.vy, b.vz, rotationY);
  const vLen = Math.sqrt(vr.x * vr.x + vr.y * vr.y) || 1;
  const vnx = vr.x / vLen, vny = vr.y / vLen;

  const headLen = size * 2.8;
  const wingSpread = size * 1.4;
  const keelDrop = size * 0.5;

  // Tip (nose)
  const tx = p.sx + vnx * headLen;
  const ty = p.sy + vny * headLen;
  // Left wing
  const lwx = p.sx - vnx * size + vny * wingSpread;
  const lwy = p.sy - vny * size - vnx * wingSpread;
  // Right wing
  const rwx = p.sx - vnx * size - vny * wingSpread;
  const rwy = p.sy - vny * size + vnx * wingSpread;
  // Center spine (slightly offset for keel)
  const cx = p.sx - vnx * size * 0.3 + vny * keelDrop;
  const cy = p.sy - vny * size * 0.3 - vnx * keelDrop;

  // --- Draw 3 faces ---

  // Left face (tip -> left wing -> center)
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(lwx, lwy);
  ctx.lineTo(cx, cy);
  ctx.closePath();
  ctx.fillStyle = faceColor(bLeft, specLeft);
  ctx.fill();

  // Right face (tip -> right wing -> center)
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(rwx, rwy);
  ctx.lineTo(cx, cy);
  ctx.closePath();
  ctx.fillStyle = faceColor(bRight, specRight);
  ctx.fill();

  // Top face (tip -> left wing -> right wing)
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(lwx, lwy);
  ctx.lineTo(rwx, rwy);
  ctx.closePath();
  ctx.fillStyle = faceColor(bTop, specTop);
  ctx.fill();

  // --- Edge highlights for definition ---
  ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(0.25, attenuation * 0.2)})`;
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(tx, ty); ctx.lineTo(lwx, lwy);
  ctx.moveTo(tx, ty); ctx.lineTo(rwx, rwy);
  ctx.moveTo(tx, ty); ctx.lineTo(cx, cy);
  ctx.stroke();

  // --- Specular hotspot ---
  const maxSpec = Math.max(specLeft, specRight, specTop);
  if (maxSpec > 0.08) {
    const hx = p.sx + vnx * headLen * 0.35;
    const hy = p.sy + vny * headLen * 0.35;
    const grad = ctx.createRadialGradient(hx, hy, 0, hx, hy, size * 0.8);
    grad.addColorStop(0, `rgba(255, 255, 255, ${maxSpec * 0.9})`);
    grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(hx, hy, size * 0.8, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Glow from light ---
  const glowStrength = bTop * attenuation;
  if (glowStrength > 0.2) {
    ctx.shadowColor = faceColor(bTop, 0);
    ctx.shadowBlur = size * 2.5 * glowStrength;
    ctx.beginPath();
    ctx.moveTo(tx, ty); ctx.lineTo(lwx, lwy); ctx.lineTo(rwx, rwy);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// --- White box with semi-transparent front faces ---
const BOX_FACES = (() => {
  const B = BOUNDS;
  return [
    { pts: [[B,-B,-B],[B,B,-B],[B,B,B],[B,-B,B]], nx:1,ny:0,nz:0 },      // +x
    { pts: [[-B,-B,B],[-B,B,B],[-B,B,-B],[-B,-B,-B]], nx:-1,ny:0,nz:0 },  // -x
    { pts: [[-B,B,-B],[-B,B,B],[B,B,B],[B,B,-B]], nx:0,ny:1,nz:0 },       // +y
    { pts: [[-B,-B,B],[-B,-B,-B],[B,-B,-B],[B,-B,B]], nx:0,ny:-1,nz:0 },   // -y
    { pts: [[-B,-B,B],[B,-B,B],[B,B,B],[-B,B,B]], nx:0,ny:0,nz:1 },       // +z (far)
    { pts: [[B,-B,-B],[-B,-B,-B],[-B,B,-B],[B,B,-B]], nx:0,ny:0,nz:-1 },  // -z (near)
  ];
})();

function drawFace(face, style) {
  const projected = face.pts.map(c => project(c[0], c[1], c[2]));
  ctx.fillStyle = style;
  ctx.beginPath();
  ctx.moveTo(projected[0].sx, projected[0].sy);
  for (let i = 1; i < projected.length; i++) ctx.lineTo(projected[i].sx, projected[i].sy);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawBoxBack(light3D) {
  const lLen = Math.sqrt(light3D.x ** 2 + light3D.y ** 2 + light3D.z ** 2) || 1;

  for (const face of BOX_FACES) {
    const rn = rotateYAxis(face.nx, face.ny, face.nz, rotationY);
    if (rn.z < 0) continue; // skip front faces in this pass

    const lightDot = Math.max(0, (face.nx * light3D.x + face.ny * light3D.y + face.nz * light3D.z) / lLen);
    const shade = Math.floor(175 + lightDot * 65);
    drawFace(face, `rgb(${shade}, ${shade}, ${shade})`);
  }
}

// Clip region = projected back faces (visible box area)
function clipToBox() {
  ctx.beginPath();
  for (const face of BOX_FACES) {
    const rn = rotateYAxis(face.nx, face.ny, face.nz, rotationY);
    if (rn.z < 0) continue;
    const projected = face.pts.map(c => project(c[0], c[1], c[2]));
    ctx.moveTo(projected[0].sx, projected[0].sy);
    for (let i = 1; i < projected.length; i++) ctx.lineTo(projected[i].sx, projected[i].sy);
    ctx.closePath();
  }
  ctx.clip();
}

function drawBoxFront() {
  for (const face of BOX_FACES) {
    const rn = rotateYAxis(face.nx, face.ny, face.nz, rotationY);
    if (rn.z >= 0) continue; // skip back faces in this pass

    // Front face — semi-transparent so boids show through
    drawFace(face, 'rgba(255, 255, 255, 0.12)');
  }
}

// --- Manage boid count ---
function syncBoidCount() {
  while (boids.length < targetCount) boids.push(createBoid());
  while (boids.length > targetCount && boids.length > 1) boids.pop();
}

// --- Input ---
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === '+' || e.key === '=') {
    targetCount = Math.min(500, targetCount + 10);
    syncBoidCount();
  }
  if (e.key === '-' || e.key === '_') {
    targetCount = Math.max(10, targetCount - 10);
    syncBoidCount();
  }
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','+','=','-','_','PageUp','PageDown'].includes(e.key)) {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => keys[e.key] = false);
window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
window.addEventListener('mousedown', e => { mouseDown = true; });
window.addEventListener('mouseup', e => { mouseDown = false; });

// Mouse wheel zoom
window.addEventListener('wheel', e => {
  e.preventDefault();
  zoom = Math.min(3.0, Math.max(0.3, zoom - e.deltaY * 0.001));
}, { passive: false });

// Social force slider
const socialSlider = document.getElementById('social-slider');
socialSlider.addEventListener('input', e => {
  socialForce = parseInt(e.target.value) / 100;
});

// --- Touch support ---
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let touchActive = false;
let longPressTimer = null;
let lastPinchAngle = 0;
let lastPinchDist = 0;
let twoFingerActive = false;

if (isTouchDevice) {
  document.getElementById('touch-controls').style.display = 'flex';
  document.getElementById('touch-hint').style.display = 'block';
  document.getElementById('desktop-hints').style.display = 'none';
  document.getElementById('mobile-hints').style.display = 'block';

  // Touch button controls
  const btnFaster = document.getElementById('btn-faster');
  const btnSlower = document.getElementById('btn-slower');
  const btnMore = document.getElementById('btn-more');
  const btnFewer = document.getElementById('btn-fewer');

  let btnInterval = null;
  function startRepeat(fn) { fn(); btnInterval = setInterval(fn, 100); }
  function stopRepeat() { clearInterval(btnInterval); btnInterval = null; }

  btnFaster.addEventListener('touchstart', e => { e.preventDefault(); startRepeat(() => speedMultiplier = Math.min(5, speedMultiplier + 0.05)); });
  btnFaster.addEventListener('touchend', e => { e.preventDefault(); stopRepeat(); });
  btnSlower.addEventListener('touchstart', e => { e.preventDefault(); startRepeat(() => speedMultiplier = Math.max(0.1, speedMultiplier - 0.05)); });
  btnSlower.addEventListener('touchend', e => { e.preventDefault(); stopRepeat(); });
  btnMore.addEventListener('touchstart', e => { e.preventDefault(); targetCount = Math.min(500, targetCount + 10); syncBoidCount(); });
  btnFewer.addEventListener('touchstart', e => { e.preventDefault(); targetCount = Math.max(10, targetCount - 10); syncBoidCount(); });
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touches = e.touches;

  if (touches.length === 1) {
    touchActive = true;
    mouseX = touches[0].clientX;
    mouseY = touches[0].clientY;
    mouseDown = false;
    // Start long press detection for repel
    longPressTimer = setTimeout(() => { mouseDown = true; }, 300);
  }

  if (touches.length === 2) {
    // Cancel long press if second finger arrives
    clearTimeout(longPressTimer);
    mouseDown = false;
    twoFingerActive = true;
    const dx = touches[1].clientX - touches[0].clientX;
    const dy = touches[1].clientY - touches[0].clientY;
    lastPinchAngle = Math.atan2(dy, dx);
    lastPinchDist = Math.sqrt(dx * dx + dy * dy);
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const touches = e.touches;

  if (touches.length === 1 && !twoFingerActive) {
    mouseX = touches[0].clientX;
    mouseY = touches[0].clientY;
    // Cancel long press if finger moves significantly
    clearTimeout(longPressTimer);
  }

  if (touches.length === 2) {
    const dx = touches[1].clientX - touches[0].clientX;
    const dy = touches[1].clientY - touches[0].clientY;

    // Rotation from angle change
    const angle = Math.atan2(dy, dx);
    const angleDelta = angle - lastPinchAngle;
    rotationVel += angleDelta * 0.3;
    lastPinchAngle = angle;

    // Zoom from pinch distance change
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (lastPinchDist > 0) {
      const scale = dist / lastPinchDist;
      zoom = Math.min(3.0, Math.max(0.3, zoom * scale));
    }
    lastPinchDist = dist;

    // Track center of two fingers as cursor
    mouseX = (touches[0].clientX + touches[1].clientX) / 2;
    mouseY = (touches[0].clientY + touches[1].clientY) / 2;
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  clearTimeout(longPressTimer);
  if (e.touches.length === 0) {
    touchActive = false;
    mouseDown = false;
    twoFingerActive = false;
  } else if (e.touches.length === 1) {
    twoFingerActive = false;
    mouseX = e.touches[0].clientX;
    mouseY = e.touches[0].clientY;
  }
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  clearTimeout(longPressTimer);
  touchActive = false;
  mouseDown = false;
  twoFingerActive = false;
}, { passive: false });

// --- Loop ---
let lastTime = performance.now();
let fpsFrames = 0, fpsLastTime = performance.now(), fpsValue = 0;
function loop(now) {
  const rawDt = Math.min((now - lastTime) / 16.667, 3); // normalize to ~60fps
  lastTime = now;

  // Handle continuous keys
  if (keys['ArrowUp'])    speedMultiplier = Math.min(5, speedMultiplier + 0.02);
  if (keys['ArrowDown'])  speedMultiplier = Math.max(0.1, speedMultiplier - 0.02);
  if (keys['ArrowLeft'])  rotationVel -= 0.002;
  if (keys['ArrowRight']) rotationVel += 0.002;
  if (keys['PageUp'])     zoom = Math.min(3.0, zoom + 0.02);
  if (keys['PageDown'])   zoom = Math.max(0.3, zoom - 0.02);

  rotationY += rotationVel;
  rotationVel *= 0.95; // friction

  // FPS counter
  fpsFrames++;
  if (now - fpsLastTime >= 500) {
    fpsValue = Math.round(fpsFrames / ((now - fpsLastTime) / 1000));
    fpsFrames = 0;
    fpsLastTime = now;
  }

  // Update HUD
  document.getElementById('fpsDisplay').textContent = fpsValue;
  document.getElementById('countDisplay').textContent = boids.length;
  document.getElementById('speedDisplay').textContent = speedMultiplier.toFixed(2);
  document.getElementById('rotDisplay').textContent = ((rotationY * 180 / Math.PI) % 360).toFixed(1);
  document.getElementById('zoomDisplay').textContent = zoom.toFixed(2);
  document.getElementById('socialDisplay').textContent = socialForce.toFixed(2);
  document.getElementById('cursorDisplay').textContent = `${Math.round(mouseX)}, ${Math.round(mouseY)}`;

  // Physics
  updateBoids(rawDt);

  // Light source in 3D = cursor unprojected
  const light3D = unprojectMouse(mouseX, mouseY);

  // Render — full clear
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#1a1a20';
  ctx.fillRect(0, 0, W, H);

  // Back walls (opaque white, behind boids)
  drawBoxBack(light3D);

  // Depth-sort boids with screen positions
  const sorted = boids
    .map(b => ({ b, ...project(b.x, b.y, b.z) }))
    .sort((a, b) => b.depth - a.depth);

  // Clip spotlight + shadows to box outline
  ctx.save();
  clipToBox();

  // Spotlight vignette
  ctx.save();
  ctx.globalCompositeOperation = 'multiply';
  const spotGrad = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, Math.max(W, H) * 0.7);
  spotGrad.addColorStop(0, 'rgb(255, 255, 255)');
  spotGrad.addColorStop(0.35, 'rgb(240, 240, 243)');
  spotGrad.addColorStop(1, 'rgb(160, 160, 175)');
  ctx.fillStyle = spotGrad;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();

  // Projected boid shadows on walls
  drawWallShadows(light3D);

  // Soft shadow volumes (atmospheric)
  drawShadowVolumes(sorted);

  ctx.restore(); // end box clip

  // Boid pass with lighting
  for (const { b } of sorted) drawBoid(b, light3D);

  // Front walls (semi-transparent, over boids)
  drawBoxFront();

  // Cursor light orb (drawn on top)
  drawCursorOrb();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
