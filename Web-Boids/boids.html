<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>3D Boid Simulation</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; touch-action: none; }
  canvas { display: block; touch-action: none; }
  #hud {
    position: fixed; top: 10px; left: 10px;
    color: rgba(255,255,255,0.7); font-size: 13px; line-height: 1.6;
    pointer-events: none; user-select: none;
  }
  #hud span { color: #0ff; }
  #touch-controls {
    display: none;
    position: fixed; bottom: 16px; left: 0; right: 0;
    justify-content: center; gap: 10px;
    pointer-events: none; user-select: none; z-index: 10;
  }
  #touch-controls button {
    pointer-events: auto;
    width: 52px; height: 52px; border-radius: 50%;
    border: 1.5px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.08);
    color: #fff; font-size: 18px; font-family: inherit;
    backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
    cursor: pointer; display: flex; align-items: center; justify-content: center;
  }
  #touch-controls button:active { background: rgba(255,255,255,0.25); }
  #touch-hint {
    display: none;
    position: fixed; bottom: 78px; left: 0; right: 0;
    text-align: center; color: rgba(255,255,255,0.4); font-size: 11px;
    pointer-events: none; user-select: none;
  }
  #social-slider-wrap {
    position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
    display: flex; align-items: center; gap: 8px;
    z-index: 10; user-select: none;
  }
  #social-slider-wrap label {
    color: rgba(255,255,255,0.5); font-size: 11px; font-family: 'Courier New', monospace;
    white-space: nowrap;
  }
  #social-slider {
    -webkit-appearance: none; appearance: none;
    width: 140px; height: 4px; border-radius: 2px;
    background: linear-gradient(to right, #f06030, #333 40%, #333 60%, #30c0f0);
    outline: none; cursor: pointer;
  }
  #social-slider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 14px; height: 14px; border-radius: 50%;
    background: #fff; border: 1.5px solid rgba(255,255,255,0.4);
    box-shadow: 0 0 6px rgba(255,255,255,0.3);
  }
  #social-slider::-moz-range-thumb {
    width: 14px; height: 14px; border-radius: 50%;
    background: #fff; border: 1.5px solid rgba(255,255,255,0.4);
    box-shadow: 0 0 6px rgba(255,255,255,0.3);
  }
</style>
</head>
<body>
<div id="hud">
  FPS: <span id="fpsDisplay">0</span><br>
  Boids: <span id="countDisplay">150</span><br>
  Speed: <span id="speedDisplay">1.00</span>x<br>
  Rotation: <span id="rotDisplay">0.0</span>&deg;<br>
  Social: <span id="socialDisplay">0.00</span><br>
  Cursor: <span id="cursorDisplay">0, 0</span><br><br>
  <small id="desktop-hints">
    Arrow Up/Down &mdash; speed<br>
    Arrow Left/Right &mdash; rotate<br>
    +/&minus; &mdash; add/remove boids<br>
    Mouse &mdash; attract | Click &mdash; repel
  </small>
  <small id="mobile-hints" style="display:none">
    Drag &mdash; attract | Two-finger drag &mdash; rotate<br>
    Long press &mdash; repel | Buttons below &mdash; controls
  </small>
</div>
<div id="touch-controls">
  <button id="btn-slower" aria-label="Slower">&#9661;</button>
  <button id="btn-faster" aria-label="Faster">&#9651;</button>
  <button id="btn-fewer" aria-label="Fewer boids">&minus;</button>
  <button id="btn-more" aria-label="More boids">+</button>
</div>
<div id="touch-hint">Drag to attract &bull; Long press to repel</div>
<div id="social-slider-wrap">
  <label id="social-label-repel">repel</label>
  <input type="range" id="social-slider" min="-100" max="100" value="0" step="1">
  <label id="social-label-attract">attract</label>
</div>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H;

// Offscreen canvas for volumetric fog (half res for performance)
const fogCanvas = document.createElement('canvas');
const fogCtx = fogCanvas.getContext('2d');
let fogW, fogH;
const FOG_SCALE = 0.5;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  fogW = fogCanvas.width = Math.ceil(W * FOG_SCALE);
  fogH = fogCanvas.height = Math.ceil(H * FOG_SCALE);
}
resize();
window.addEventListener('resize', resize);

// --- State ---
let boids = [];
let speedMultiplier = 1.0;
let rotationY = 0;        // radians
let rotationVel = 0;
let mouseX = W / 2, mouseY = H / 2;
let mouseDown = false;
let targetCount = 150;
let socialForce = 0; // -1 (repel) to +1 (attract)

const BOUNDS = 400;        // 3D cube half-size
const FOV = 600;
const MAX_SPEED = 4;
const VISUAL_RANGE = 80;
const SEPARATION_DIST = 30;

// --- Boid ---
function createBoid(x, y, z) {
  return {
    x: x ?? (Math.random() - 0.5) * BOUNDS * 2,
    y: y ?? (Math.random() - 0.5) * BOUNDS * 2,
    z: z ?? (Math.random() - 0.5) * BOUNDS * 2,
    vx: (Math.random() - 0.5) * 2,
    vy: (Math.random() - 0.5) * 2,
    vz: (Math.random() - 0.5) * 2,
    hue: Math.random() * 360,
  };
}

for (let i = 0; i < targetCount; i++) boids.push(createBoid());

// --- Projection ---
function rotateYAxis(x, y, z, angle) {
  const c = Math.cos(angle), s = Math.sin(angle);
  return { x: x * c + z * s, y, z: -x * s + z * c };
}

function project(x, y, z) {
  const r = rotateYAxis(x, y, z, rotationY);
  const perspective = FOV / (FOV + r.z + BOUNDS * 1.5);
  return {
    sx: W / 2 + r.x * perspective,
    sy: H / 2 + r.y * perspective,
    depth: r.z,
    scale: perspective,
  };
}

// --- Unproject mouse into 3D (on z=0 plane after rotation) ---
function unprojectMouse(mx, my) {
  const perspective = FOV / (FOV + BOUNDS * 1.5);
  const wx = (mx - W / 2) / perspective;
  const wy = (my - H / 2) / perspective;
  const c = Math.cos(-rotationY), s = Math.sin(-rotationY);
  return { x: wx * c, y: wy, z: -wx * s };
}

// --- Boid rules ---
function updateBoids(dt) {
  const mouse3D = unprojectMouse(mouseX, mouseY);
  const n = boids.length;

  for (let i = 0; i < n; i++) {
    const b = boids[i];
    let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;
    let aliX = 0, aliY = 0, aliZ = 0, aliCount = 0;
    let sepX = 0, sepY = 0, sepZ = 0;

    for (let j = 0; j < n; j++) {
      if (i === j) continue;
      const o = boids[j];
      const dx = o.x - b.x, dy = o.y - b.y, dz = o.z - b.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

      if (dist < VISUAL_RANGE) {
        cohX += o.x; cohY += o.y; cohZ += o.z;
        cohCount++;
        aliX += o.vx; aliY += o.vy; aliZ += o.vz;
        aliCount++;
      }
      if (dist < SEPARATION_DIST && dist > 0) {
        sepX -= dx / dist;
        sepY -= dy / dist;
        sepZ -= dz / dist;
      }
    }

    // Cohesion — socialForce scales from -1 (anti-cohere) to 3x at full attract
    const cohScale = 0.005 * (1 + socialForce * 2);
    if (cohCount > 0) {
      cohX = (cohX / cohCount - b.x) * cohScale;
      cohY = (cohY / cohCount - b.y) * cohScale;
      cohZ = (cohZ / cohCount - b.z) * cohScale;
    }

    // Alignment
    if (aliCount > 0) {
      aliX = (aliX / aliCount - b.vx) * 0.04;
      aliY = (aliY / aliCount - b.vy) * 0.04;
      aliZ = (aliZ / aliCount - b.vz) * 0.04;
    }

    // Separation — socialForce scales from 2x at full repel to 0 at full attract
    const sepScale = 0.15 * (1 - socialForce);
    sepX *= sepScale;
    sepY *= sepScale;
    sepZ *= sepScale;

    // Mouse attraction / repulsion
    const mdx = mouse3D.x - b.x;
    const mdy = mouse3D.y - b.y;
    const mdz = mouse3D.z - b.z;
    const mDist = Math.sqrt(mdx * mdx + mdy * mdy + mdz * mdz) || 1;
    const mouseForce = mouseDown ? -0.12 : 0.03;
    const repelFalloff = mouseDown ? Math.min(1, 300 / (mDist + 1)) : 1;
    const mfx = (mdx / mDist) * mouseForce * repelFalloff;
    const mfy = (mdy / mDist) * mouseForce * repelFalloff;
    const mfz = (mdz / mDist) * mouseForce * repelFalloff;

    // Boundary nudge
    let bndX = 0, bndY = 0, bndZ = 0;
    const margin = BOUNDS * 0.8;
    const turnFactor = 0.15;
    if (b.x > margin)  bndX -= turnFactor;
    if (b.x < -margin) bndX += turnFactor;
    if (b.y > margin)  bndY -= turnFactor;
    if (b.y < -margin) bndY += turnFactor;
    if (b.z > margin)  bndZ -= turnFactor;
    if (b.z < -margin) bndZ += turnFactor;

    // Apply forces
    b.vx += (cohX + aliX + sepX + mfx + bndX) * dt;
    b.vy += (cohY + aliY + sepY + mfy + bndY) * dt;
    b.vz += (cohZ + aliZ + sepZ + mfz + bndZ) * dt;

    // Limit speed
    const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy + b.vz * b.vz);
    const limit = MAX_SPEED * speedMultiplier;
    if (spd > limit) {
      b.vx = (b.vx / spd) * limit;
      b.vy = (b.vy / spd) * limit;
      b.vz = (b.vz / spd) * limit;
    }
    // Enforce minimum speed
    const minSpd = limit * 0.3;
    if (spd < minSpd && spd > 0) {
      b.vx = (b.vx / spd) * minSpd;
      b.vy = (b.vy / spd) * minSpd;
      b.vz = (b.vz / spd) * minSpd;
    }

    b.x += b.vx * dt * speedMultiplier;
    b.y += b.vy * dt * speedMultiplier;
    b.z += b.vz * dt * speedMultiplier;

    // Shift hue slowly based on speed
    b.hue = (b.hue + spd * 0.05 * dt) % 360;
  }
}

// --- Lighting ---
const LIGHT_RADIUS = 800;       // falloff distance in 3D
const AMBIENT = 0.12;           // global illumination base
const GI_BOUNCE = 0.08;         // simulated bounce light
const LIGHT_INTENSITY = 1.4;

function hslToRgb(h, s, l) {
  s /= 100; l /= 100;
  const k = n => (n + h / 30) % 12;
  const a = s * Math.min(l, 1 - l);
  const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
  return [f(0) * 255, f(8) * 255, f(4) * 255];
}

// --- Volumetric Fog / God Rays ---
let fogTime = 0;

function drawVolumetricFog(sorted, dt) {
  fogTime += dt * 0.01;
  const fmx = mouseX * FOG_SCALE;
  const fmy = mouseY * FOG_SCALE;
  const repel = mouseDown;
  const maxR = Math.max(fogW, fogH) * 0.95;

  fogCtx.clearRect(0, 0, fogW, fogH);

  // --- Base radial light volume ---
  const grad = fogCtx.createRadialGradient(fmx, fmy, 0, fmx, fmy, maxR);
  if (repel) {
    grad.addColorStop(0, 'rgba(255, 130, 60, 0.18)');
    grad.addColorStop(0.25, 'rgba(255, 80, 30, 0.10)');
    grad.addColorStop(0.6, 'rgba(180, 40, 10, 0.04)');
  } else {
    grad.addColorStop(0, 'rgba(120, 190, 255, 0.16)');
    grad.addColorStop(0.25, 'rgba(70, 140, 220, 0.09)');
    grad.addColorStop(0.6, 'rgba(30, 70, 150, 0.03)');
  }
  grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  fogCtx.fillStyle = grad;
  fogCtx.fillRect(0, 0, fogW, fogH);

  // --- God rays (radial beams with animated shimmer) ---
  fogCtx.save();
  fogCtx.globalCompositeOperation = 'lighter';
  const rayCount = 120;
  for (let i = 0; i < rayCount; i++) {
    const baseAngle = (i / rayCount) * Math.PI * 2;
    const shimmer = Math.sin(fogTime * 3 + i * 1.7) * 0.02;
    const angle = baseAngle + shimmer;
    const rayLen = maxR * (0.6 + Math.sin(i * 5.3 + fogTime * 2) * 0.15 + Math.sin(i * 13.1) * 0.2);
    const intensity = 0.012 + Math.sin(i * 3.7 + fogTime * 4) * 0.005;

    fogCtx.strokeStyle = repel
      ? `rgba(255, 100, 40, ${intensity})`
      : `rgba(100, 170, 255, ${intensity})`;
    fogCtx.lineWidth = 1.5 + Math.sin(i * 2.1) * 0.8;
    fogCtx.beginPath();
    fogCtx.moveTo(fmx, fmy);
    fogCtx.lineTo(fmx + Math.cos(angle) * rayLen, fmy + Math.sin(angle) * rayLen);
    fogCtx.stroke();
  }
  fogCtx.restore();

  // --- Second pass: wider soft rays for scatter ---
  fogCtx.save();
  fogCtx.globalCompositeOperation = 'lighter';
  const scatterCount = 40;
  for (let i = 0; i < scatterCount; i++) {
    const angle = (i / scatterCount) * Math.PI * 2 + fogTime * 0.3;
    const rayLen = maxR * 0.7;
    fogCtx.strokeStyle = repel
      ? 'rgba(255, 80, 30, 0.006)'
      : 'rgba(80, 140, 220, 0.006)';
    fogCtx.lineWidth = 6;
    fogCtx.beginPath();
    fogCtx.moveTo(fmx, fmy);
    fogCtx.lineTo(fmx + Math.cos(angle) * rayLen, fmy + Math.sin(angle) * rayLen);
    fogCtx.stroke();
  }
  fogCtx.restore();

  // --- Cut shadow volumes for each boid ---
  fogCtx.save();
  fogCtx.globalCompositeOperation = 'destination-out';

  for (const { b, sx, sy, scale } of sorted) {
    const bx = sx * FOG_SCALE;
    const by = sy * FOG_SCALE;
    const dx = bx - fmx;
    const dy = by - fmy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) continue;

    const nx = dx / dist;
    const ny = dy / dist;
    const px = -ny;
    const py = nx;

    // Boid angular width in fog
    const boidWidth = Math.max(2.5, 7 * scale) * FOG_SCALE;
    const shadowLen = maxR * 1.2;

    // Spread factor: shadow widens further from boid
    const spread = 2.5;

    // Near edge (at boid position)
    const n1x = bx + px * boidWidth;
    const n1y = by + py * boidWidth;
    const n2x = bx - px * boidWidth;
    const n2y = by - py * boidWidth;

    // Far edge (extended away from light)
    const f1x = bx + nx * shadowLen + px * boidWidth * spread;
    const f1y = by + ny * shadowLen + py * boidWidth * spread;
    const f2x = bx + nx * shadowLen - px * boidWidth * spread;
    const f2y = by + ny * shadowLen - py * boidWidth * spread;

    // Shadow strength based on depth (closer boids cast stronger shadows)
    const shadowAlpha = Math.min(0.85, Math.max(0.15, scale * 1.0));

    fogCtx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
    fogCtx.beginPath();
    fogCtx.moveTo(n1x, n1y);
    fogCtx.lineTo(f1x, f1y);
    fogCtx.lineTo(f2x, f2y);
    fogCtx.lineTo(n2x, n2y);
    fogCtx.closePath();
    fogCtx.fill();
  }

  fogCtx.restore();

  // --- Composite fog onto main canvas ---
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.drawImage(fogCanvas, 0, 0, W, H);
  ctx.restore();

  // Extra soft ambient glow layer directly on main canvas
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  const ambGrad = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, Math.max(W, H) * 0.5);
  ambGrad.addColorStop(0, repel ? 'rgba(80, 30, 10, 0.06)' : 'rgba(20, 40, 70, 0.06)');
  ambGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = ambGrad;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
}

function drawCursorOrb() {
  ctx.save();
  const repel = mouseDown;

  // Outer glow
  const g1 = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, repel ? 160 : 120);
  g1.addColorStop(0, repel ? 'rgba(255, 120, 80, 0.2)' : 'rgba(150, 230, 255, 0.15)');
  g1.addColorStop(0.3, repel ? 'rgba(255, 60, 30, 0.08)' : 'rgba(80, 180, 255, 0.06)');
  g1.addColorStop(1, 'rgba(0, 0, 0, 0)');
  ctx.fillStyle = g1;
  const outerR = repel ? 160 : 120;
  ctx.fillRect(mouseX - outerR, mouseY - outerR, outerR * 2, outerR * 2);

  // Mid glow
  const g2 = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 40);
  g2.addColorStop(0, repel ? 'rgba(255, 180, 140, 0.55)' : 'rgba(200, 240, 255, 0.5)');
  g2.addColorStop(0.4, repel ? 'rgba(255, 80, 40, 0.25)' : 'rgba(100, 200, 255, 0.2)');
  g2.addColorStop(1, repel ? 'rgba(200, 0, 0, 0)' : 'rgba(0, 100, 200, 0)');
  ctx.fillStyle = g2;
  ctx.beginPath();
  ctx.arc(mouseX, mouseY, 40, 0, Math.PI * 2);
  ctx.fill();

  // Core
  const g3 = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 12);
  g3.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
  g3.addColorStop(0.5, repel ? 'rgba(255, 160, 120, 0.7)' : 'rgba(180, 230, 255, 0.7)');
  g3.addColorStop(1, repel ? 'rgba(255, 60, 20, 0)' : 'rgba(80, 180, 255, 0)');
  ctx.fillStyle = g3;
  ctx.beginPath();
  ctx.arc(mouseX, mouseY, 12, 0, Math.PI * 2);
  ctx.fill();

  // Bright center dot
  ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
  ctx.beginPath();
  ctx.arc(mouseX, mouseY, 3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawBoid(b, light3D) {
  const p = project(b.x, b.y, b.z);
  if (p.scale <= 0) return;

  const size = Math.max(2.5, 7 * p.scale);

  // --- Light vector ---
  const lx = light3D.x - b.x, ly = light3D.y - b.y, lz = light3D.z - b.z;
  const lightDist = Math.sqrt(lx * lx + ly * ly + lz * lz) || 1;
  const lnx = lx / lightDist, lny = ly / lightDist, lnz = lz / lightDist;

  // Distance attenuation
  const attenuation = Math.min(1, LIGHT_RADIUS * LIGHT_RADIUS / (lightDist * lightDist + 200));

  // Boid forward direction (velocity normalized)
  const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy + b.vz * b.vz) || 1;
  const fwdX = b.vx / spd, fwdY = b.vy / spd, fwdZ = b.vz / spd;

  // Build a local coordinate frame for the boid
  // "up" = cross(forward, arbitrary) to get a wing axis
  let upX = 0, upY = -1, upZ = 0;
  // Wing axis = cross(forward, up)
  let wingX = fwdY * upZ - fwdZ * upY;
  let wingY = fwdZ * upX - fwdX * upZ;
  let wingZ = fwdX * upY - fwdY * upX;
  const wLen = Math.sqrt(wingX * wingX + wingY * wingY + wingZ * wingZ) || 1;
  wingX /= wLen; wingY /= wLen; wingZ /= wLen;
  // Recompute up = cross(wing, forward)
  upX = wingY * fwdZ - wingZ * fwdY;
  upY = wingZ * fwdX - wingX * fwdZ;
  upZ = wingX * fwdY - wingY * fwdX;

  // --- Per-face normals ---
  // Left wing face normal: cross(forward, wing+up)
  const leftNx = fwdY * (wingZ + upZ) - fwdZ * (wingY + upY);
  const leftNy = fwdZ * (wingX + upX) - fwdX * (wingZ + upZ);
  const leftNz = fwdX * (wingY + upY) - fwdY * (wingX + upX);
  const leftLen = Math.sqrt(leftNx*leftNx + leftNy*leftNy + leftNz*leftNz) || 1;

  const rightNx = -leftNx, rightNy = -leftNy, rightNz = -leftNz;

  // Top face normal ~= up
  const topNx = upX, topNy = upY, topNz = upZ;

  // Diffuse per face
  const diffLeft  = Math.max(0, (leftNx/leftLen)*lnx + (leftNy/leftLen)*lny + (leftNz/leftLen)*lnz);
  const diffRight = Math.max(0, (rightNx/leftLen)*lnx + (rightNy/leftLen)*lny + (rightNz/leftLen)*lnz);
  const diffTop   = Math.max(0, topNx*lnx + topNy*lny + topNz*lnz);

  // Specular per face (Blinn-Phong)
  // View direction approx: towards camera (0,0,-1) in rotated space
  const viewZ = -1;
  const halfX = lnx, halfY = lny, halfZ = (lnz + viewZ);
  const hLen = Math.sqrt(halfX*halfX + halfY*halfY + halfZ*halfZ) || 1;
  const hnx = halfX/hLen, hny = halfY/hLen, hnz = halfZ/hLen;
  const specLeft  = Math.pow(Math.max(0, (leftNx/leftLen)*hnx + (leftNy/leftLen)*hny + (leftNz/leftLen)*hnz), 32) * attenuation;
  const specRight = Math.pow(Math.max(0, (rightNx/leftLen)*hnx + (rightNy/leftLen)*hny + (rightNz/leftLen)*hnz), 32) * attenuation;
  const specTop   = Math.pow(Math.max(0, topNx*hnx + topNy*hny + topNz*hnz), 32) * attenuation;

  // Brightness per face
  const bLeft  = Math.min(1, AMBIENT + GI_BOUNCE + diffLeft  * LIGHT_INTENSITY * attenuation);
  const bRight = Math.min(1, AMBIENT + GI_BOUNCE + diffRight * LIGHT_INTENSITY * attenuation);
  const bTop   = Math.min(1, AMBIENT + GI_BOUNCE + diffTop   * LIGHT_INTENSITY * attenuation);

  // Base color
  const [baseR, baseG, baseB] = hslToRgb(b.hue, 85, 45);
  const alpha = Math.min(1, 0.5 + p.scale * 0.6);

  // Color per face
  function faceColor(brightness, spec) {
    const r = Math.min(255, baseR * brightness + spec * 220 + attenuation * 25) | 0;
    const g = Math.min(255, baseG * brightness + spec * 230 + attenuation * 30) | 0;
    const bl = Math.min(255, baseB * brightness + spec * 255 + attenuation * 35) | 0;
    return `rgba(${r}, ${g}, ${bl}, ${alpha})`;
  }

  // Screen-space vertices
  const vr = rotateYAxis(b.vx, b.vy, b.vz, rotationY);
  const vLen = Math.sqrt(vr.x * vr.x + vr.y * vr.y) || 1;
  const vnx = vr.x / vLen, vny = vr.y / vLen;

  const headLen = size * 2.8;
  const wingSpread = size * 1.4;
  const keelDrop = size * 0.5;

  // Tip (nose)
  const tx = p.sx + vnx * headLen;
  const ty = p.sy + vny * headLen;
  // Left wing
  const lwx = p.sx - vnx * size + vny * wingSpread;
  const lwy = p.sy - vny * size - vnx * wingSpread;
  // Right wing
  const rwx = p.sx - vnx * size - vny * wingSpread;
  const rwy = p.sy - vny * size + vnx * wingSpread;
  // Center spine (slightly offset for keel)
  const cx = p.sx - vnx * size * 0.3 + vny * keelDrop;
  const cy = p.sy - vny * size * 0.3 - vnx * keelDrop;

  // --- Draw 3 faces ---

  // Left face (tip -> left wing -> center)
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(lwx, lwy);
  ctx.lineTo(cx, cy);
  ctx.closePath();
  ctx.fillStyle = faceColor(bLeft, specLeft);
  ctx.fill();

  // Right face (tip -> right wing -> center)
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(rwx, rwy);
  ctx.lineTo(cx, cy);
  ctx.closePath();
  ctx.fillStyle = faceColor(bRight, specRight);
  ctx.fill();

  // Top face (tip -> left wing -> right wing)
  ctx.beginPath();
  ctx.moveTo(tx, ty);
  ctx.lineTo(lwx, lwy);
  ctx.lineTo(rwx, rwy);
  ctx.closePath();
  ctx.fillStyle = faceColor(bTop, specTop);
  ctx.fill();

  // --- Edge highlights for definition ---
  ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(0.25, attenuation * 0.2)})`;
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(tx, ty); ctx.lineTo(lwx, lwy);
  ctx.moveTo(tx, ty); ctx.lineTo(rwx, rwy);
  ctx.moveTo(tx, ty); ctx.lineTo(cx, cy);
  ctx.stroke();

  // --- Specular hotspot ---
  const maxSpec = Math.max(specLeft, specRight, specTop);
  if (maxSpec > 0.08) {
    const hx = p.sx + vnx * headLen * 0.35;
    const hy = p.sy + vny * headLen * 0.35;
    const grad = ctx.createRadialGradient(hx, hy, 0, hx, hy, size * 0.8);
    grad.addColorStop(0, `rgba(255, 255, 255, ${maxSpec * 0.9})`);
    grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(hx, hy, size * 0.8, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- Glow from light ---
  const glowStrength = bTop * attenuation;
  if (glowStrength > 0.2) {
    ctx.shadowColor = faceColor(bTop, 0);
    ctx.shadowBlur = size * 2.5 * glowStrength;
    ctx.beginPath();
    ctx.moveTo(tx, ty); ctx.lineTo(lwx, lwy); ctx.lineTo(rwx, rwy);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function drawBounds() {
  const corners = [
    [-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],
    [-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1],
  ].map(c => project(c[0]*BOUNDS, c[1]*BOUNDS, c[2]*BOUNDS));

  const edges = [
    [0,1],[1,2],[2,3],[3,0],
    [4,5],[5,6],[6,7],[7,4],
    [0,4],[1,5],[2,6],[3,7],
  ];

  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1;
  for (const [a, b] of edges) {
    ctx.beginPath();
    ctx.moveTo(corners[a].sx, corners[a].sy);
    ctx.lineTo(corners[b].sx, corners[b].sy);
    ctx.stroke();
  }
}

// --- Manage boid count ---
function syncBoidCount() {
  while (boids.length < targetCount) boids.push(createBoid());
  while (boids.length > targetCount && boids.length > 1) boids.pop();
}

// --- Input ---
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === '+' || e.key === '=') {
    targetCount = Math.min(500, targetCount + 10);
    syncBoidCount();
  }
  if (e.key === '-' || e.key === '_') {
    targetCount = Math.max(10, targetCount - 10);
    syncBoidCount();
  }
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','+','=','-','_'].includes(e.key)) {
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => keys[e.key] = false);
window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
window.addEventListener('mousedown', e => { mouseDown = true; });
window.addEventListener('mouseup', e => { mouseDown = false; });

// Social force slider
const socialSlider = document.getElementById('social-slider');
socialSlider.addEventListener('input', e => {
  socialForce = parseInt(e.target.value) / 100;
});

// --- Touch support ---
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let touchActive = false;
let longPressTimer = null;
let lastPinchDist = 0;
let twoFingerRotating = false;

if (isTouchDevice) {
  document.getElementById('touch-controls').style.display = 'flex';
  document.getElementById('touch-hint').style.display = 'block';
  document.getElementById('desktop-hints').style.display = 'none';
  document.getElementById('mobile-hints').style.display = 'block';
  document.getElementById('social-slider-wrap').style.bottom = '80px';

  // Touch button controls
  const btnFaster = document.getElementById('btn-faster');
  const btnSlower = document.getElementById('btn-slower');
  const btnMore = document.getElementById('btn-more');
  const btnFewer = document.getElementById('btn-fewer');

  let btnInterval = null;
  function startRepeat(fn) { fn(); btnInterval = setInterval(fn, 100); }
  function stopRepeat() { clearInterval(btnInterval); btnInterval = null; }

  btnFaster.addEventListener('touchstart', e => { e.preventDefault(); startRepeat(() => speedMultiplier = Math.min(5, speedMultiplier + 0.05)); });
  btnFaster.addEventListener('touchend', e => { e.preventDefault(); stopRepeat(); });
  btnSlower.addEventListener('touchstart', e => { e.preventDefault(); startRepeat(() => speedMultiplier = Math.max(0.1, speedMultiplier - 0.05)); });
  btnSlower.addEventListener('touchend', e => { e.preventDefault(); stopRepeat(); });
  btnMore.addEventListener('touchstart', e => { e.preventDefault(); targetCount = Math.min(500, targetCount + 10); syncBoidCount(); });
  btnFewer.addEventListener('touchstart', e => { e.preventDefault(); targetCount = Math.max(10, targetCount - 10); syncBoidCount(); });
}

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touches = e.touches;

  if (touches.length === 1) {
    touchActive = true;
    mouseX = touches[0].clientX;
    mouseY = touches[0].clientY;
    mouseDown = false;
    // Start long press detection for repel
    longPressTimer = setTimeout(() => { mouseDown = true; }, 300);
  }

  if (touches.length === 2) {
    // Cancel long press if second finger arrives
    clearTimeout(longPressTimer);
    mouseDown = false;
    twoFingerRotating = true;
    const dx = touches[1].clientX - touches[0].clientX;
    const dy = touches[1].clientY - touches[0].clientY;
    lastPinchDist = Math.atan2(dy, dx);
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const touches = e.touches;

  if (touches.length === 1 && !twoFingerRotating) {
    mouseX = touches[0].clientX;
    mouseY = touches[0].clientY;
    // Cancel long press if finger moves significantly
    clearTimeout(longPressTimer);
  }

  if (touches.length === 2) {
    const dx = touches[1].clientX - touches[0].clientX;
    const dy = touches[1].clientY - touches[0].clientY;
    const angle = Math.atan2(dy, dx);
    const delta = angle - lastPinchDist;
    rotationVel += delta * 0.3;
    lastPinchDist = angle;

    // Track center of two fingers as cursor
    mouseX = (touches[0].clientX + touches[1].clientX) / 2;
    mouseY = (touches[0].clientY + touches[1].clientY) / 2;
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  clearTimeout(longPressTimer);
  if (e.touches.length === 0) {
    touchActive = false;
    mouseDown = false;
    twoFingerRotating = false;
  } else if (e.touches.length === 1) {
    twoFingerRotating = false;
    mouseX = e.touches[0].clientX;
    mouseY = e.touches[0].clientY;
  }
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  clearTimeout(longPressTimer);
  touchActive = false;
  mouseDown = false;
  twoFingerRotating = false;
}, { passive: false });

// --- Loop ---
let lastTime = performance.now();
let fpsFrames = 0, fpsLastTime = performance.now(), fpsValue = 0;
function loop(now) {
  const rawDt = Math.min((now - lastTime) / 16.667, 3); // normalize to ~60fps
  lastTime = now;

  // Handle continuous keys
  if (keys['ArrowUp'])    speedMultiplier = Math.min(5, speedMultiplier + 0.02);
  if (keys['ArrowDown'])  speedMultiplier = Math.max(0.1, speedMultiplier - 0.02);
  if (keys['ArrowLeft'])  rotationVel -= 0.002;
  if (keys['ArrowRight']) rotationVel += 0.002;

  rotationY += rotationVel;
  rotationVel *= 0.95; // friction

  // FPS counter
  fpsFrames++;
  if (now - fpsLastTime >= 500) {
    fpsValue = Math.round(fpsFrames / ((now - fpsLastTime) / 1000));
    fpsFrames = 0;
    fpsLastTime = now;
  }

  // Update HUD
  document.getElementById('fpsDisplay').textContent = fpsValue;
  document.getElementById('countDisplay').textContent = boids.length;
  document.getElementById('speedDisplay').textContent = speedMultiplier.toFixed(2);
  document.getElementById('rotDisplay').textContent = ((rotationY * 180 / Math.PI) % 360).toFixed(1);
  document.getElementById('socialDisplay').textContent = socialForce.toFixed(2);
  document.getElementById('cursorDisplay').textContent = `${Math.round(mouseX)}, ${Math.round(mouseY)}`;

  // Physics
  updateBoids(rawDt);

  // Light source in 3D = cursor unprojected
  const light3D = unprojectMouse(mouseX, mouseY);

  // Render — full clear, no trails
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#030306';
  ctx.fillRect(0, 0, W, H);

  drawBounds();

  // Depth-sort boids with screen positions
  const sorted = boids
    .map(b => ({ b, ...project(b.x, b.y, b.z) }))
    .sort((a, b) => b.depth - a.depth);

  // Volumetric fog with god rays + shadow volumes (behind boids)
  drawVolumetricFog(sorted, rawDt);

  // Boid pass with lighting
  for (const { b } of sorted) drawBoid(b, light3D);

  // Cursor light orb (drawn on top)
  drawCursorOrb();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
